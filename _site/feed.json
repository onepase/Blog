{
    "version": "https://jsonfeed.org/version/1",
    "title": "Hakan Torun",
    "home_page_url": "https://hakan.io/",
    "feed_url": "https://hakan.io/feed.json",
    "description": "Hakan Torun Kişisel Blog Sitesi. Bilgisayar mühendisliği, yazılım geliştirme, siber güvenlik ve çeşitli konularda blog gönderilerine erişebilirsiniz.",
    "icon": "https://hakan.io/assets/images/apple-touch-icon.png",
    "favicon": "https://hakan.io/assets/images/favicon.png",
    "expired": false,
    
    "author":  {
        "name": "Hakan Torun",
        "url": null,
        "avatar": null
    },
    
"items": [
    
        {
            "id": "https://hakan.io/nasa-voyager-2-uzay-araci-18-5-milyar-km-uzakta-teknik-ariza-yasadi/",
            "title": "NASA Voyager 2 Uzay Aracı 18.5 Milyar Km Uzakta Teknik Arıza Yaşadı",
            "summary": null,
            "content_text": "Voyager 2 1977 yılında görevine başladı. Aradan geçen zamana ve yol aldığı mesafeye göre olağanüstü bir dayanıklılık gösterdi. Uzay aracının yoluna devam etmesi için ihtiyaç duyduğu enerjiyi sağlama yeterliliği günden güne azalıyor. Buna rağmen hala bilim insanlarının güneş sisteminin sınırlarında neler olduğu ile ilgili çalışması için veri toplamaya devam ediyor. NASA’nın Voyager uzay araçlarından Voyager 2, Dünya’dan 18.5 milyar km uzakta teknik bir arıza yaşadı.Görsel: NASAVoyager 1 ve Voyager 2 en uzak mesafedeki insan yapımı uzay araçları olarak 1977’den beri görevlerini sürdürüyorlar. NASA Voyager Twitter hesabından yapılan açıklamada, Voyager 2’nin dahili manyetometresinde meydana gelen bir arızanın yaşandığı ve otomatik sistemleri sayesinde yoluna devam ediyor olduğu belirtildi. NASA yaptığı paylaşımda; Voyager 2’nin güç durumunun iyi olduğunu ve cihazlarının tekrar çalışmaya başladığını da yazdı.Voyager uzay aracının Dünya’ya gönderdiği sinyaller 17 saatte ulaşıyor. Yine Dünya’dan gönderilen sinyallerin uzay aracına ulaşması da 17 saat sürüyor.Voyager uzay araçları, üzerinde bulunan plak kaydının çalışma prensibine dair çizimler bulunan ve farklı dillerden mesajların yer aldığı plak kayıtlarıyla yola çıkmıştı. Bu plak kaydında Türkçe bir mesaj da bulunuyor. Türkçe mesaj; “Sayın Türkçe bilen arkadaşlarımız, sabah şerifleriniz hayrolsun.” şeklinde.",
            "content_html": "<p>Voyager 2 1977 yılında görevine başladı. Aradan geçen zamana ve yol aldığı mesafeye göre olağanüstü bir dayanıklılık gösterdi. Uzay aracının yoluna devam etmesi için ihtiyaç duyduğu enerjiyi sağlama yeterliliği günden güne azalıyor. Buna rağmen hala bilim insanlarının güneş sisteminin sınırlarında neler olduğu ile ilgili çalışması için veri toplamaya devam ediyor. NASA’nın Voyager uzay araçlarından Voyager 2, Dünya’dan 18.5 milyar km uzakta teknik bir arıza yaşadı.</p><p><img src=\"/assets/images/post/nasa-voyager-2.jpg\" alt=\"NASA Voyager 2\" title=\"NASA Voyager 2\" /><em>Görsel: NASA</em></p><p>Voyager 1 ve Voyager 2 en uzak mesafedeki insan yapımı uzay araçları olarak 1977’den beri görevlerini sürdürüyorlar. NASA Voyager Twitter hesabından yapılan açıklamada, Voyager 2’nin dahili manyetometresinde meydana gelen bir arızanın yaşandığı ve otomatik sistemleri sayesinde yoluna devam ediyor olduğu belirtildi. NASA yaptığı paylaşımda; Voyager 2’nin güç durumunun iyi olduğunu ve cihazlarının tekrar çalışmaya başladığını da yazdı.</p><p>Voyager uzay aracının Dünya’ya gönderdiği sinyaller 17 saatte ulaşıyor. Yine Dünya’dan gönderilen sinyallerin uzay aracına ulaşması da 17 saat sürüyor.</p><p>Voyager uzay araçları, üzerinde bulunan plak kaydının çalışma prensibine dair çizimler bulunan ve farklı dillerden mesajların yer aldığı plak kayıtlarıyla yola çıkmıştı. Bu plak kaydında Türkçe bir mesaj da bulunuyor. Türkçe mesaj; “Sayın Türkçe bilen arkadaşlarımız, sabah şerifleriniz hayrolsun.” şeklinde.</p>",
            "url": "https://hakan.io/nasa-voyager-2-uzay-araci-18-5-milyar-km-uzakta-teknik-ariza-yasadi/",
            
            
            
            "tags": ["nasa","voyager"],
            
            "date_published": "2020-01-30T03:00:00+03:00",
            "date_modified": "2020-01-30T03:00:00+03:00",
            
                "author": "Hakan"
            
        },
    
        {
            "id": "https://hakan.io/wikileaks-kurucusu-julian-assange-tutuklanmasi-uzerine/",
            "title": "Wikileaks Kurucusu Julian Assange'ın Tutuklanması Üzerine",
            "summary": null,
            "content_text": "Wikileaks kurucusu Julian Assange, Londra’daki Ekvador Büyükelçiliğinde tutuklandı. Hakkında gerçekleştirilen suçlamalar sonucunda açılan dava sebebiyle, İsveç’e iade edilmesini önlemek için sığındığı Ekvador Büyükelçiliğine sığınmasının üzerinden yedi yıl geçtikten sonra, bugün Ekvador hükümeti tarafından siyasi sığınması geri çekildi ve hemen ardından Julian Assange Londra Polisi tarafından tutuklandı.Tutuklamanın ardından Ekvador devlet başkanı Lenín Moreno paylaştığı tweet ile “Julian Assange’ın sığınma durumu, uluslararası sözleşmelere ve günlük yaşam protokollerine yönelik tekrarlanan ihlallerden sonra geri çekildi” ifadelerini kullandı.Ancak Wikileaks tarafından yapılan açıklamada, Ekvador’un, Assange’ın siyasi sığınmasının uluslararası hukuka aykırı bir şekilde sona erdirmek için yasadışı davrandığı belirtildi.Assange, İngiliz polisi tarafından Ağustos 2012’de Westminster Mahkemesine teslim olmadığı ve İsveç’teki cinsel saldırı iddiaları nedeniyle soruşturma altına alındığı için aranmıştı.İsveç, Assange’a karşı 2017 yılında başlatılan cinsel saldırı suçlamasıyla ilgili soruşturmayı bırakmış olmasına rağmen, Assange ABD’ye iade edilme korkusuyla Ekvador Büyükelçiliğinde sığınmacı olarak kalmayı seçmişti.Julian Assange ABD’de Wikileaks aracılığıyla diplomatik ve askeri belgeleri sızdırdığı iddiasıyla federal suçlamalarla da karşı karşıya. Ancak ABD Assange aleyhindeki suçlamalarla ilgili bugüne kadar resmi olarak bir adım atmadı.47 yaşındaki hacker ve aktivist Jullian Assange, 2006 yılında Wikileaks’i kurdu ve o zamandan beri dünyadaki birçok siyasi parti, şahıs ve devlet kurumlarıyla ilgili sırları açığa çıkardı.Assange, Haziran 2012’den beri Londra’daki Ekvador Büyükelçiliğinde yaşamaya zorlandı ve o tarihten beri orada yaşıyor. Bir İngiltere mahkemesi tarafından İsveç’e iadesi istenmiş ve cinsel saldırı suçlamasıyla karşı karşıya kalmıştı. Bu tarihten beri Ekvador ile olan ilişkisi geçen yıl kötüleşmiş ve Ekvador diğer ülkelerle olan ilişkilerini etkileyebileceği iddiasıyla Assange’ın internet erişimini Mart 2018’de kesmişti. Bu koşullar Assange’ın Wikileaks’i yönetmesini zorlaştırmış ve Wikileaks genel yayıncısı olarak Kristinn Hrafnsson olmuştu.Süreç Nasıl Gelişti?Julian Assange, 2006 yılında Wikileaks’i kurduktan sonra Wikileaks üzerinden kamuoyuna açıklanan belgeler ile Dünya gündemine oturmuştu.Assange her ne kadar Wikileaks kurucusu olarak anılsa da, kendisi ile beraber toplamda dokuz kişilik yönetim kurulu üyesinden birisi ve konuyla ilgili “Ben kendimi kurucu olarak görmüyorum, sadece editörüm.” demişti.2010 yılında, Wikileaks üzerinden kamuoyuna açıklanan belgeler sebebiyle bir anda kendisine karşı bir karalama kampanyasına başlanmıştı. Yine 2010 yılında İsveç, cinsel taciz suçlamasıyla Assange hakkında uluslararası yakalama kararı çıkardı.Gönüllü olarak ifade vermeye gittiği Londra’daki polis merkezinde İsveç tarafından yakalama emri olduğu gerekçesiyle tutuklanmıştı. Çıktığı duruşmada şartlı tahliye edilmişti.Assange, kendisine yöneltilen bu suçlamayı kabul etmemiş ve kendisinin cinsel taciz suçlaması adı altında siyasi olarak sıkıştırılmaya çalışıldığını belirtmişti.19 Haziran 2012 tarihinden itibaren Londra’daki Ekvador Büyükelçiliğinde yaşamaya başlayan Assange’ın siyasi sığınma talebi, 16 Ağustos 2012 tarihinde onaylanmıştı. İngiltere hükümeti resmi olarak Ekvador hükümetini bu kararından dolayı uyarmıştı.İngiltere hükümeti Assange’ın ülkeden çıkmasına izin verilmeyeceğini, hatta gerekirse elçilik binasına girileceğini açıklamıştı. 2012’den beri Assange, Ekvador Büyükelçiliğinde bir nevi hapis hayatı gibi bir hayat yaşıyordu.2017 Mayıs ayında, İsveç Assange hakkında yürütülen cinsel taciz soruşturmasını düşürdü. Ancak ABD’ye teslim edilme ihtimaline karşın, Julian Assange Ekvador büyükelçilik binasında yaşamaya devam etti.2018 Mart ayında ise, Ekvador, diğer ülkelerle olan ilişkilerini etkileyebileceği iddiasıyla Assange’ın internet erişimini kesti. Wikileaks genel yayın yönetmeni ise Kristinn Hrafnsson oldu.Geçtiğimiz hafta, Wikileaks Twitter hesabından yapılan açıklamada, Julian Assange’ın Londra’daki Ekvador büyükelçiliğinden çıkarılıp gözaltına alınması için İngiltere ile gizli bir anlaşma yapıldığı iddia edilmişti.Gerekçe olarak ise, Wikileaks’in Ekvador devlet başkanı Moreno hakkında ortaya attığı yolsuzluk iddialarının üzerinin örtülmesi girişimi olabileceği öne sürülmüştü.Bugün ise Ekvador Assange’ın siyasi sığınma statüsünü, uluslararası sözleşmelere ve sığınma hakkına dair günlük yaşam protokollerine yönelik tekrarlanan ihlalleri gerekçe (!) göstererek geri çekti.Hemen ardından Londra polisi elçilik binasında Julian Assange’ı, daha önce mahkemeye çıkmadığı için tutuklama emri olduğu gerekçesiyle tutukladı.",
            "content_html": "<p>Wikileaks kurucusu Julian Assange, Londra’daki Ekvador Büyükelçiliğinde tutuklandı. Hakkında gerçekleştirilen suçlamalar sonucunda açılan dava sebebiyle, İsveç’e iade edilmesini önlemek için sığındığı Ekvador Büyükelçiliğine sığınmasının üzerinden yedi yıl geçtikten sonra, bugün Ekvador hükümeti tarafından siyasi sığınması geri çekildi ve hemen ardından Julian Assange Londra Polisi tarafından tutuklandı.</p><p><img src=\"/assets/images/post/julian-assange-tutuklanma.jpg\" alt=\"Julian Assange\" title=\"Julian Assange\" /></p><p>Tutuklamanın ardından Ekvador devlet başkanı Lenín Moreno paylaştığı tweet ile “Julian Assange’ın sığınma durumu, uluslararası sözleşmelere ve günlük yaşam protokollerine yönelik tekrarlanan ihlallerden sonra geri çekildi” ifadelerini kullandı.</p><p>Ancak Wikileaks tarafından yapılan açıklamada, Ekvador’un, Assange’ın siyasi sığınmasının uluslararası hukuka aykırı bir şekilde sona erdirmek için yasadışı davrandığı belirtildi.</p><p>Assange, İngiliz polisi tarafından Ağustos 2012’de Westminster Mahkemesine teslim olmadığı ve İsveç’teki cinsel saldırı iddiaları nedeniyle soruşturma altına alındığı için aranmıştı.</p><p>İsveç, Assange’a karşı 2017 yılında başlatılan cinsel saldırı suçlamasıyla ilgili soruşturmayı bırakmış olmasına rağmen, Assange ABD’ye iade edilme korkusuyla Ekvador Büyükelçiliğinde sığınmacı olarak kalmayı seçmişti.</p><p><img src=\"/assets/images/post/julian-assange-2.jpg\" alt=\"Julian Assange\" title=\"Julian Assange\" /></p><p>Julian Assange ABD’de Wikileaks aracılığıyla diplomatik ve askeri belgeleri sızdırdığı iddiasıyla federal suçlamalarla da karşı karşıya. Ancak ABD Assange aleyhindeki suçlamalarla ilgili bugüne kadar resmi olarak bir adım atmadı.</p><p>47 yaşındaki hacker ve aktivist Jullian Assange, 2006 yılında Wikileaks’i kurdu ve o zamandan beri dünyadaki birçok siyasi parti, şahıs ve devlet kurumlarıyla ilgili sırları açığa çıkardı.</p><p>Assange, Haziran 2012’den beri Londra’daki Ekvador Büyükelçiliğinde yaşamaya zorlandı ve o tarihten beri orada yaşıyor. Bir İngiltere mahkemesi tarafından İsveç’e iadesi istenmiş ve cinsel saldırı suçlamasıyla karşı karşıya kalmıştı. Bu tarihten beri Ekvador ile olan ilişkisi geçen yıl kötüleşmiş ve Ekvador diğer ülkelerle olan ilişkilerini etkileyebileceği iddiasıyla Assange’ın internet erişimini Mart 2018’de kesmişti. Bu koşullar Assange’ın Wikileaks’i yönetmesini zorlaştırmış ve Wikileaks genel yayıncısı olarak Kristinn Hrafnsson olmuştu.</p><p><strong>Süreç Nasıl Gelişti?</strong></p><p>Julian Assange, 2006 yılında Wikileaks’i kurduktan sonra Wikileaks üzerinden kamuoyuna açıklanan belgeler ile Dünya gündemine oturmuştu.</p><p>Assange her ne kadar Wikileaks kurucusu olarak anılsa da, kendisi ile beraber toplamda dokuz kişilik yönetim kurulu üyesinden birisi ve konuyla ilgili “Ben kendimi kurucu olarak görmüyorum, sadece editörüm.” demişti.</p><p>2010 yılında, Wikileaks üzerinden kamuoyuna açıklanan belgeler sebebiyle bir anda kendisine karşı bir karalama kampanyasına başlanmıştı. Yine 2010 yılında İsveç, cinsel taciz suçlamasıyla Assange hakkında uluslararası yakalama kararı çıkardı.</p><p>Gönüllü olarak ifade vermeye gittiği Londra’daki polis merkezinde İsveç tarafından yakalama emri olduğu gerekçesiyle tutuklanmıştı. Çıktığı duruşmada şartlı tahliye edilmişti.</p><p>Assange, kendisine yöneltilen bu suçlamayı kabul etmemiş ve kendisinin cinsel taciz suçlaması adı altında siyasi olarak sıkıştırılmaya çalışıldığını belirtmişti.</p><p>19 Haziran 2012 tarihinden itibaren Londra’daki Ekvador Büyükelçiliğinde yaşamaya başlayan Assange’ın siyasi sığınma talebi, 16 Ağustos 2012 tarihinde onaylanmıştı. İngiltere hükümeti resmi olarak Ekvador hükümetini bu kararından dolayı uyarmıştı.</p><p>İngiltere hükümeti Assange’ın ülkeden çıkmasına izin verilmeyeceğini, hatta gerekirse elçilik binasına girileceğini açıklamıştı. 2012’den beri Assange, Ekvador Büyükelçiliğinde bir nevi hapis hayatı gibi bir hayat yaşıyordu.</p><p>2017 Mayıs ayında, İsveç Assange hakkında yürütülen cinsel taciz soruşturmasını düşürdü. Ancak ABD’ye teslim edilme ihtimaline karşın, Julian Assange Ekvador büyükelçilik binasında yaşamaya devam etti.</p><p>2018 Mart ayında ise, Ekvador, diğer ülkelerle olan ilişkilerini etkileyebileceği iddiasıyla Assange’ın internet erişimini kesti. Wikileaks genel yayın yönetmeni ise Kristinn Hrafnsson oldu.</p><p>Geçtiğimiz hafta, Wikileaks Twitter hesabından yapılan açıklamada, Julian Assange’ın Londra’daki Ekvador büyükelçiliğinden çıkarılıp gözaltına alınması için İngiltere ile gizli bir anlaşma yapıldığı iddia edilmişti.</p><p>Gerekçe olarak ise, Wikileaks’in Ekvador devlet başkanı Moreno hakkında ortaya attığı yolsuzluk iddialarının üzerinin örtülmesi girişimi olabileceği öne sürülmüştü.</p><p>Bugün ise Ekvador Assange’ın siyasi sığınma statüsünü, uluslararası sözleşmelere ve sığınma hakkına dair günlük yaşam protokollerine yönelik tekrarlanan ihlalleri gerekçe (!) göstererek geri çekti.</p><p>Hemen ardından Londra polisi elçilik binasında Julian Assange’ı, daha önce mahkemeye çıkmadığı için tutuklama emri olduğu gerekçesiyle tutukladı.</p>",
            "url": "https://hakan.io/wikileaks-kurucusu-julian-assange-tutuklanmasi-uzerine/",
            
            
            
            "tags": ["wikileaks","julian assange"],
            
            "date_published": "2019-11-04T03:00:00+03:00",
            "date_modified": "2019-11-04T03:00:00+03:00",
            
                "author": "Hakan"
            
        },
    
        {
            "id": "https://hakan.io/goldbach-hipotezi-sanisi-c-programlama-dili-ile-ornek-kod/",
            "title": "Goldbach Hipotezi / Sanısı - C Programlama Dili İle Örnek Kod",
            "summary": null,
            "content_text": "Goldbach hipotezi veya sanısı, 2’den büyük her çift tam sayının iki asal sayının toplamı şeklinde yazılabileceği iddiasıdır. İspatlanamamış en büyük matematik problemlerinden biridir. Orijinal Goldbach hipotezinde, Goldbach; 2’den büyük her tamsayının 3 asal sayının toplamı şeklinde ifade edilebileceğini iddia eder. 1 sayısının da asal sayı olduğu düşünülerek bu iddia ortaya atılmıştır. Sonrasında 1 asal sayı olarak kabul edilmediği için bu iddia geçerliliğini yitirmiştir. Goldbach hipotezi veya sanısı olarak ele aldığımız bu iddia, Euler’in “2’den büyük her çift tam sayı, iki asal sayının toplamından bulunabilir” şeklindeki düzeltmesini kapsamaktadır.Örnek olarak; 4,6,8,10,12 çift tam sayıları şu şekilde iki asal sayının toplamı şeklinde yazılabilir.4 = 2 + 26 = 3 + 38 = 3 + 510 = 3 + 712 = 5 + 72’den büyük bir çift tam sayının, iki asal sayının toplamı şeklinde yazılmasının çözüm kümesinde en küçük asal sayıyı içeren ayrışımı bulabilecek örnek bir C kodu şu şekilde olacaktır.Örnek C Kodu#include &lt;stdio.h&gt;//Fonksyion deklarasyonlarıint is_prime(int n);void goldbach(int g);int main(){\tint number = 0;\twhile(1){\t\tprintf(\"Enter even number:\");\t\tscanf(\"%d\",&amp;number);\t\tif(number&gt;2 &amp;&amp; number%2==0){\t\t\tgoldbach(number);\t\t}\t\telse{\t\t\tprintf(\"Incorrect number!\\n\");\t\t}\t\tprintf(\"\\n\");\t}\treturn 0;}//Asal sayı kontrolu j &lt; n/2, bir sayinin yarisindan buyuk tam boleni olamazint is_prime(int n){\tint flag = 1;\tfor (int j = 2; j &lt; n/2; j++)\t{\t\tif((n%j) == 0){\t\t\treturn flag-1;\t\t}\t}\treturn flag;}//Iki'den buyuk bir cift tam sayinin min goldbach cozumuvoid goldbach(int g){\tint i = 2;\tfor (int j = g-i; j &gt; 2; j--)\t{\t\tif(is_prime(i) == 1 &amp;&amp; is_prime(j) == 1)\t\t{\t\t\tprintf(\"%d = %d + %d\\n\",g,i,j);\t\t\tbreak;\t\t}\t\ti++;\t}}2’den büyük bir çift tam sayının, iki farklı asal sayının toplamı şeklindeki tüm çözüm kümesini ekrana yazan örnek bir C kodu ise şu şekilde olacaktır.#include &lt;stdio.h&gt;//Asal sayilar icin tamponint primes[100000] = {2};int j = 0;//Fonksyion deklarasyonlarıint is_prime(int n);void goldbach(int g);int main(){\tint number = 0;\twhile(1){\t\tprintf(\"Enter even number:\");\t\tscanf(\"%d\",&amp;number);\t\tif(number&gt;2 &amp;&amp; number%2==0){\t\t\tgoldbach(number);\t\t}\t\telse{\t\t\tprintf(\"Incorrect number!\\n\");\t\t}\t\tprintf(\"\\n\");\t}\treturn 0;}//Asal sayı kontrolu j &lt; n/2, bir sayinin yarisindan buyuk tam boleni olamazint is_prime(int n){\tint flag = 1;\tfor (int j = 2; j &lt; n/2; j++)\t{\t\tif((n%j) == 0){\t\t\treturn flag-1;\t\t}\t}\treturn flag;}//Iki'den buyuk cift tam sayinin iki asal sayi olarak toplamlarini ifade eden tam cozum kumesivoid goldbach(int g){\tint flag = 0;\tif(primes[j]&lt;g){\t\tfor (int i = primes[j]+1; i &lt; g; i++)\t\t{\t\t\tif(is_prime(i) == 1){\t\t\t\tj++;\t\t\t\tprimes[j] = i;\t\t\t}\t\t}\t\t\t}\tfor (int i = 0; i &lt; j; i++)\t{\t\tfor (int k = 0; k &lt; j; k++)\t\t{\t\t\tif(primes[i] + primes[k] == g){\t\t\t\tprintf(\"%d = %d + %d\\n\",g,primes[i],primes[k]);\t\t\t\tbreak;\t\t\t}\t\t}\t}}",
            "content_html": "<p>Goldbach hipotezi veya sanısı, 2’den büyük her çift tam sayının iki asal sayının toplamı şeklinde yazılabileceği iddiasıdır. İspatlanamamış en büyük matematik problemlerinden biridir. Orijinal Goldbach hipotezinde, Goldbach; 2’den büyük her tamsayının 3 asal sayının toplamı şeklinde ifade edilebileceğini iddia eder. 1 sayısının da asal sayı olduğu düşünülerek bu iddia ortaya atılmıştır. Sonrasında 1 asal sayı olarak kabul edilmediği için bu iddia geçerliliğini yitirmiştir. Goldbach hipotezi veya sanısı olarak ele aldığımız bu iddia, Euler’in “2’den büyük her çift tam sayı, iki asal sayının toplamından bulunabilir” şeklindeki düzeltmesini kapsamaktadır.</p><p>Örnek olarak; 4,6,8,10,12 çift tam sayıları şu şekilde iki asal sayının toplamı şeklinde yazılabilir.</p><p>4 = 2 + 26 = 3 + 38 = 3 + 510 = 3 + 712 = 5 + 7</p><p>2’den büyük bir çift tam sayının, iki asal sayının toplamı şeklinde yazılmasının çözüm kümesinde en küçük asal sayıyı içeren ayrışımı bulabilecek örnek bir C kodu şu şekilde olacaktır.</p><p>Örnek C Kodu</p><figure class=\"highlight\"><pre><code class=\"language-c\" data-lang=\"c\"><span class=\"cp\">#include &lt;stdio.h&gt;</span><span class=\"c1\">//Fonksyion deklarasyonları</span><span class=\"kt\">int</span> <span class=\"nf\">is_prime</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"p\">);</span><span class=\"kt\">void</span> <span class=\"nf\">goldbach</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">g</span><span class=\"p\">);</span><span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">(){</span>\t<span class=\"kt\">int</span> <span class=\"n\">number</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\t<span class=\"k\">while</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">){</span>\t\t<span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"Enter even number:\"</span><span class=\"p\">);</span>\t\t<span class=\"n\">scanf</span><span class=\"p\">(</span><span class=\"s\">\"%d\"</span><span class=\"p\">,</span><span class=\"o\">&amp;</span><span class=\"n\">number</span><span class=\"p\">);</span>\t\t<span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">number</span><span class=\"o\">&gt;</span><span class=\"mi\">2</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">number</span><span class=\"o\">%</span><span class=\"mi\">2</span><span class=\"o\">==</span><span class=\"mi\">0</span><span class=\"p\">){</span>\t\t\t<span class=\"n\">goldbach</span><span class=\"p\">(</span><span class=\"n\">number</span><span class=\"p\">);</span>\t\t<span class=\"p\">}</span>\t\t<span class=\"k\">else</span><span class=\"p\">{</span>\t\t\t<span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"Incorrect number!</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">);</span>\t\t<span class=\"p\">}</span>\t\t<span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">);</span>\t<span class=\"p\">}</span>\t<span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"p\">}</span><span class=\"c1\">//Asal sayı kontrolu j &lt; n/2, bir sayinin yarisindan buyuk tam boleni olamaz</span><span class=\"kt\">int</span> <span class=\"nf\">is_prime</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"p\">){</span>\t<span class=\"kt\">int</span> <span class=\"n\">flag</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\t<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">/</span><span class=\"mi\">2</span><span class=\"p\">;</span> <span class=\"n\">j</span><span class=\"o\">++</span><span class=\"p\">)</span>\t<span class=\"p\">{</span>\t\t<span class=\"k\">if</span><span class=\"p\">((</span><span class=\"n\">n</span><span class=\"o\">%</span><span class=\"n\">j</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">){</span>\t\t\t<span class=\"k\">return</span> <span class=\"n\">flag</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\t\t<span class=\"p\">}</span>\t<span class=\"p\">}</span>\t<span class=\"k\">return</span> <span class=\"n\">flag</span><span class=\"p\">;</span><span class=\"p\">}</span><span class=\"c1\">//Iki'den buyuk bir cift tam sayinin min goldbach cozumu</span><span class=\"kt\">void</span> <span class=\"nf\">goldbach</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">g</span><span class=\"p\">){</span>\t<span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\t<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">g</span><span class=\"o\">-</span><span class=\"n\">i</span><span class=\"p\">;</span> <span class=\"n\">j</span> <span class=\"o\">&gt;</span> <span class=\"mi\">2</span><span class=\"p\">;</span> <span class=\"n\">j</span><span class=\"o\">--</span><span class=\"p\">)</span>\t<span class=\"p\">{</span>\t\t<span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">is_prime</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">is_prime</span><span class=\"p\">(</span><span class=\"n\">j</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\t\t<span class=\"p\">{</span>\t\t\t<span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"%d = %d + %d</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">,</span><span class=\"n\">g</span><span class=\"p\">,</span><span class=\"n\">i</span><span class=\"p\">,</span><span class=\"n\">j</span><span class=\"p\">);</span>\t\t\t<span class=\"k\">break</span><span class=\"p\">;</span>\t\t<span class=\"p\">}</span>\t\t<span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">;</span>\t<span class=\"p\">}</span><span class=\"p\">}</span></code></pre></figure><p>2’den büyük bir çift tam sayının, iki farklı asal sayının toplamı şeklindeki tüm çözüm kümesini ekrana yazan örnek bir C kodu ise şu şekilde olacaktır.</p><figure class=\"highlight\"><pre><code class=\"language-c\" data-lang=\"c\"><span class=\"cp\">#include &lt;stdio.h&gt;</span><span class=\"c1\">//Asal sayilar icin tampon</span><span class=\"kt\">int</span> <span class=\"n\">primes</span><span class=\"p\">[</span><span class=\"mi\">100000</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"mi\">2</span><span class=\"p\">};</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"c1\">//Fonksyion deklarasyonları</span><span class=\"kt\">int</span> <span class=\"nf\">is_prime</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"p\">);</span><span class=\"kt\">void</span> <span class=\"nf\">goldbach</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">g</span><span class=\"p\">);</span><span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">(){</span>\t<span class=\"kt\">int</span> <span class=\"n\">number</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\t<span class=\"k\">while</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">){</span>\t\t<span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"Enter even number:\"</span><span class=\"p\">);</span>\t\t<span class=\"n\">scanf</span><span class=\"p\">(</span><span class=\"s\">\"%d\"</span><span class=\"p\">,</span><span class=\"o\">&amp;</span><span class=\"n\">number</span><span class=\"p\">);</span>\t\t<span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">number</span><span class=\"o\">&gt;</span><span class=\"mi\">2</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">number</span><span class=\"o\">%</span><span class=\"mi\">2</span><span class=\"o\">==</span><span class=\"mi\">0</span><span class=\"p\">){</span>\t\t\t<span class=\"n\">goldbach</span><span class=\"p\">(</span><span class=\"n\">number</span><span class=\"p\">);</span>\t\t<span class=\"p\">}</span>\t\t<span class=\"k\">else</span><span class=\"p\">{</span>\t\t\t<span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"Incorrect number!</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">);</span>\t\t<span class=\"p\">}</span>\t\t<span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">);</span>\t<span class=\"p\">}</span>\t<span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"p\">}</span><span class=\"c1\">//Asal sayı kontrolu j &lt; n/2, bir sayinin yarisindan buyuk tam boleni olamaz</span><span class=\"kt\">int</span> <span class=\"nf\">is_prime</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"p\">){</span>\t<span class=\"kt\">int</span> <span class=\"n\">flag</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\t<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">/</span><span class=\"mi\">2</span><span class=\"p\">;</span> <span class=\"n\">j</span><span class=\"o\">++</span><span class=\"p\">)</span>\t<span class=\"p\">{</span>\t\t<span class=\"k\">if</span><span class=\"p\">((</span><span class=\"n\">n</span><span class=\"o\">%</span><span class=\"n\">j</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">){</span>\t\t\t<span class=\"k\">return</span> <span class=\"n\">flag</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\t\t<span class=\"p\">}</span>\t<span class=\"p\">}</span>\t<span class=\"k\">return</span> <span class=\"n\">flag</span><span class=\"p\">;</span><span class=\"p\">}</span><span class=\"c1\">//Iki'den buyuk cift tam sayinin iki asal sayi olarak toplamlarini ifade eden tam cozum kumesi</span><span class=\"kt\">void</span> <span class=\"nf\">goldbach</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">g</span><span class=\"p\">){</span>\t<span class=\"kt\">int</span> <span class=\"n\">flag</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\t<span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">primes</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span><span class=\"o\">&lt;</span><span class=\"n\">g</span><span class=\"p\">){</span>\t\t<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">primes</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">g</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span>\t\t<span class=\"p\">{</span>\t\t\t<span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">is_prime</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">){</span>\t\t\t\t<span class=\"n\">j</span><span class=\"o\">++</span><span class=\"p\">;</span>\t\t\t\t<span class=\"n\">primes</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"p\">;</span>\t\t\t<span class=\"p\">}</span>\t\t<span class=\"p\">}</span>\t\t\t<span class=\"p\">}</span>\t<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">j</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span>\t<span class=\"p\">{</span>\t\t<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">k</span> <span class=\"o\">&lt;</span> <span class=\"n\">j</span><span class=\"p\">;</span> <span class=\"n\">k</span><span class=\"o\">++</span><span class=\"p\">)</span>\t\t<span class=\"p\">{</span>\t\t\t<span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">primes</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">primes</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">g</span><span class=\"p\">){</span>\t\t\t\t<span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"%d = %d + %d</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">,</span><span class=\"n\">g</span><span class=\"p\">,</span><span class=\"n\">primes</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">],</span><span class=\"n\">primes</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">]);</span>\t\t\t\t<span class=\"k\">break</span><span class=\"p\">;</span>\t\t\t<span class=\"p\">}</span>\t\t<span class=\"p\">}</span>\t<span class=\"p\">}</span><span class=\"p\">}</span></code></pre></figure>",
            "url": "https://hakan.io/goldbach-hipotezi-sanisi-c-programlama-dili-ile-ornek-kod/",
            
            
            
            "tags": ["goldbach hipotezi","goldbach sanısı","asal sayılar","c programlama","c örnek"],
            
            "date_published": "2019-01-12T03:00:00+03:00",
            "date_modified": "2019-01-12T03:00:00+03:00",
            
                "author": "Hakan"
            
        },
    
        {
            "id": "https://hakan.io/ikili-arama-algoritmasi-binary-search-algorithm-c-ornek-kod/",
            "title": "İkili Arama Algoritması (Binary Search Algorithm) - C Örnek Kod",
            "summary": null,
            "content_text": "İkili arama algoritması, bir dizide arama yapmaya yarayan bir arama algoritmasıdır. İkili arama algoritmasında, aranan elemanın bulunabilmesi için her seferinde dizinin ortasındaki elemana bakılır. Ortadaki eleman aranan elemana eşit değilse, aranan elemanın bulunduğu diğer yarı alanda arama işlemi tekrar edilir. Bu sayede her adımda arama uzayı yarıya indirilmiş olur.İkili arama algoritmasında arama yapılacak dizinin sıralı bir dizi olması gerekir. Sıralı olmayan dizilerde, ikili arama yapabilmek için öncelikle dizinin herhangi bir sıralama algoritması ile sıralanması gerekir.İkili arama algoritmasında izlenecek adımlar şu şekildedir1- Dizinin ortasındaki elemanı seç2- Seçilen elemanı aranan elemanla karşılaştır, aranan elemana eşitse sonlandır3- Aranan eleman seçilen elemandan büyükse dizinin seçilen elemandan büyük kısmında arama işlemini tekrarla4- Aranan eleman seçilen elemandan küçükse dizinin seçilen elemandan küçük kısmında arama işlemini tekrarla5- Arama uzayındaki en küçük indis en büyük indisten küçük veya eşit oluncaya kadar adımları tekrarlaÖrnek olarak; 2,3,4,5,6,7,8,9,22,33,45 elemanlarından oluşan sıralı bir dizi içerisinde, 4 elemanının ikili arama ile bulunması için sırasıyla şu adımlar izlenecektir.Dizinin ortadaki elemanı 7 olarak seçilir ve aranan elaman olan 4 ile karşılaştırılır. Aranan eleman (4) ortadaki elemana (7) eşit olmadığı için, dizinin ortasındaki elaman olan 7’den küçük olan kısmına bakılır. Yeni arama dizimiz : 2,3,4,5,6 olur.Yeni arama dizimizin ortadaki elemanı 4 olacaktır ve arama işlemi tamamlanır.İkili arama algoritmasında, sıralı bir dizide en fazla log2N karşılaştırma yapılarak sonuca ulaşılır.İkili arama algoritmasını, örnekteki gibi sıralı bir dizide uygulamaya çalışırsak örnek bir C kodu aşağıdaki gibi olacaktır.Örnek C Kodu#include &lt;stdio.h&gt;int main(){\tint array[11] = {2,3,4,5,6,7,8,9,22,33,45};\tint low       = 0;\tint high   \t  = 10;\tint flag      = 0;\tint s         = 4;\t\twhile(low &lt;= high){\t\tint index = low+(high-low)/2;\t\tif(array[index] == s){\t\t\tflag = 1;\t\t\tprintf(\"Founded: %d \\n\",index);\t\t\tbreak;\t\t}\t\telse if(array[index] &lt; s){\t\t\tlow   = index+1;\t\t}\t\telse{\t\t\thigh = index-1;\t\t}\t}\tif(flag == 0){\t\tprintf(\"Not Found!\\n\");\t}\treturn 0;}",
            "content_html": "<p>İkili arama algoritması, bir dizide arama yapmaya yarayan bir arama algoritmasıdır. İkili arama algoritmasında, aranan elemanın bulunabilmesi için her seferinde dizinin ortasındaki elemana bakılır. Ortadaki eleman aranan elemana eşit değilse, aranan elemanın bulunduğu diğer yarı alanda arama işlemi tekrar edilir. Bu sayede her adımda arama uzayı yarıya indirilmiş olur.</p><p>İkili arama algoritmasında arama yapılacak dizinin sıralı bir dizi olması gerekir. Sıralı olmayan dizilerde, ikili arama yapabilmek için öncelikle dizinin herhangi bir sıralama algoritması ile sıralanması gerekir.</p><p>İkili arama algoritmasında izlenecek adımlar şu şekildedir</p><p>1- Dizinin ortasındaki elemanı seç2- Seçilen elemanı aranan elemanla karşılaştır, aranan elemana eşitse sonlandır3- Aranan eleman seçilen elemandan büyükse dizinin seçilen elemandan büyük kısmında arama işlemini tekrarla4- Aranan eleman seçilen elemandan küçükse dizinin seçilen elemandan küçük kısmında arama işlemini tekrarla5- Arama uzayındaki en küçük indis en büyük indisten küçük veya eşit oluncaya kadar adımları tekrarla</p><p>Örnek olarak; 2,3,4,5,6,7,8,9,22,33,45 elemanlarından oluşan sıralı bir dizi içerisinde, 4 elemanının ikili arama ile bulunması için sırasıyla şu adımlar izlenecektir.</p><p>Dizinin ortadaki elemanı 7 olarak seçilir ve aranan elaman olan 4 ile karşılaştırılır. Aranan eleman (4) ortadaki elemana (7) eşit olmadığı için, dizinin ortasındaki elaman olan 7’den küçük olan kısmına bakılır. Yeni arama dizimiz : 2,3,4,5,6 olur.</p><p>Yeni arama dizimizin ortadaki elemanı 4 olacaktır ve arama işlemi tamamlanır.</p><p>İkili arama algoritmasında, sıralı bir dizide en fazla log2N karşılaştırma yapılarak sonuca ulaşılır.</p><p>İkili arama algoritmasını, örnekteki gibi sıralı bir dizide uygulamaya çalışırsak örnek bir C kodu aşağıdaki gibi olacaktır.</p><p>Örnek C Kodu</p><figure class=\"highlight\"><pre><code class=\"language-c\" data-lang=\"c\"><span class=\"cp\">#include &lt;stdio.h&gt;</span><span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"p\">{</span>\t<span class=\"kt\">int</span> <span class=\"n\">array</span><span class=\"p\">[</span><span class=\"mi\">11</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">,</span><span class=\"mi\">6</span><span class=\"p\">,</span><span class=\"mi\">7</span><span class=\"p\">,</span><span class=\"mi\">8</span><span class=\"p\">,</span><span class=\"mi\">9</span><span class=\"p\">,</span><span class=\"mi\">22</span><span class=\"p\">,</span><span class=\"mi\">33</span><span class=\"p\">,</span><span class=\"mi\">45</span><span class=\"p\">};</span>\t<span class=\"kt\">int</span> <span class=\"n\">low</span>       <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\t<span class=\"kt\">int</span> <span class=\"n\">high</span>   \t  <span class=\"o\">=</span> <span class=\"mi\">10</span><span class=\"p\">;</span>\t<span class=\"kt\">int</span> <span class=\"n\">flag</span>      <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\t<span class=\"kt\">int</span> <span class=\"n\">s</span>         <span class=\"o\">=</span> <span class=\"mi\">4</span><span class=\"p\">;</span>\t\t<span class=\"k\">while</span><span class=\"p\">(</span><span class=\"n\">low</span> <span class=\"o\">&lt;=</span> <span class=\"n\">high</span><span class=\"p\">){</span>\t\t<span class=\"kt\">int</span> <span class=\"n\">index</span> <span class=\"o\">=</span> <span class=\"n\">low</span><span class=\"o\">+</span><span class=\"p\">(</span><span class=\"n\">high</span><span class=\"o\">-</span><span class=\"n\">low</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"mi\">2</span><span class=\"p\">;</span>\t\t<span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">array</span><span class=\"p\">[</span><span class=\"n\">index</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">s</span><span class=\"p\">){</span>\t\t\t<span class=\"n\">flag</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\t\t\t<span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"Founded: %d </span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">,</span><span class=\"n\">index</span><span class=\"p\">);</span>\t\t\t<span class=\"k\">break</span><span class=\"p\">;</span>\t\t<span class=\"p\">}</span>\t\t<span class=\"k\">else</span> <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">array</span><span class=\"p\">[</span><span class=\"n\">index</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">s</span><span class=\"p\">){</span>\t\t\t<span class=\"n\">low</span>   <span class=\"o\">=</span> <span class=\"n\">index</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">;</span>\t\t<span class=\"p\">}</span>\t\t<span class=\"k\">else</span><span class=\"p\">{</span>\t\t\t<span class=\"n\">high</span> <span class=\"o\">=</span> <span class=\"n\">index</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\t\t<span class=\"p\">}</span>\t<span class=\"p\">}</span>\t<span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">flag</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">){</span>\t\t<span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"Not Found!</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">);</span>\t<span class=\"p\">}</span>\t<span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"p\">}</span></code></pre></figure>",
            "url": "https://hakan.io/ikili-arama-algoritmasi-binary-search-algorithm-c-ornek-kod/",
            
            
            
            "tags": ["ikili arama","ikili arama algoritması","binary search","binary search algorithm","ornek","c programı","c kod"],
            
            "date_published": "2019-01-09T03:00:00+03:00",
            "date_modified": "2019-01-09T03:00:00+03:00",
            
                "author": "Hakan"
            
        },
    
        {
            "id": "https://hakan.io/memcached-kurulumu-ve-php-memcache-kullanimi/",
            "title": "Memcached Kurulumu ve PHP Memcache Kullanımı",
            "summary": null,
            "content_text": "Yüksek trafiğe sahip web sunucular, özellikle CRUD işlemlerinin fazla olduğu web sunucular, yüksek trafik sonucunda çok fazla yük altına girecektir. Böyle bir durumda, kod kaynakları yeterince verimli kullanabilecek şekilde yazılmışsa, ağır yük altında hizmet verebilmek için ilk ihtiyaç duyulanlardan biri, bir önbellek mekanizmasıdır.Memcahced nedir?Memcached 2003 yılında, alanının ilklerinden olan popüler blog servisi LiveJournal için yazılmış ve sonrasında özellikle web uygulamalarında çokça kullanılmaya başlanmış ücretiz, açık kaynak, yüksek performanslı ve dağıtık bir önbellekleme sistemidir. Basit ama güçlü bir önbellekleme sistemidir. Günümüzde Facebook tarafından aktif olarak kullanılmakta ve geliştirilmesine katkı sunulmaktadır. Yine popüler web uygulama ve servisleri tarafından (Wikipedia, Youtube, Flickr) aktif olarak kullanılmaktadır.Memcached bir in-memory storedur. Tüm önbellekleme hafıza(ram) üzerindedir. Dolayısıyla kritik verilerin yalnızca memcached üzerinde saklanmaması gerekir. Memcached üzerinde veri, key-value çiftleri olarak saklanır. Memcached özellikle veritabanı işlemlerinin fazla olduğu web uygulamalarında hayat kurtarıcıdır.Memcached KurulumDebian tabanlı Linux dağıtımlarında;apt-get install php-memcachedapt-get install memcachedRedHat/Fedora tabanlı Linux dağıtımlarında;yum install php-memcachedyum install memcachedkomutu ile Memcached ve Php-Memcached paketleri kolayca kurulabilir. Memcached TCP/IP tabanlıdır. Herhangi iki yazılım arasında memcached ile haberleşme sağlanabilir.Memcached’i başlatmak içinmemcached -d -m 512 -l 127.0.0.1 -p 11211 -u nobodykomutu kullanılabilir. Bu komut ile, 512 MB bir önbellek alanı kullanan, 11211 tcp ve udp portunu dinleyen bir memcached servisi başlatılacaktır. Memcached servisi başlatılırken oluşturulan önbellek alanı sabittir. İşletim sistemi mimarilerindeki bellek yönetimine benzer şekilde, eğer önbellek alanı dolduysa ilk yazılan verinin üzerine yazacaktır. Memcached için x86 sistemlerde maksimum 4GB önbellek alanı tanımlayabilirsiniz.Memcached başlatıldıktan sonra servisle ilgili daha fazla detay almak için;echo \"stats settings\" | nc localhost 11211komutunu kullanabilirsiniz. Varsayılan olarak, Memcached key uzunlukları 250 karakterdir. Value ise maksimum 1MB olabilir.PHP Memcached KullanımıPHP ile memcached’e bağlanmak için;$memcache = new Memcache;$memcache-&gt;connect('127.0.0.1', 11211) or die (\"Memcached ile bağlantı kurulamıyor\");Memcached üzerine veri yazmak için;$exampleValue = 2;$exampleValue = 'Example String';$exampleValue = array('0','1','2','3');$memcache-&gt;set('exampleKey', $exampleValue, false, 1800);//Birinci parametre anahtar, ikinci parametre değer, üçüncü parametre memcached sıkıştırma true/false, dördüncü parametre saniye cinsinden önbellekleme süresiMemcached üzerindeki bir anahtarın değerine ulaşmak için;$exampleValue = $memcache-&gt;get('exampleKey');Örnek bir senaryoda, web uygulamamızdaki çok sık değişmeyen bir değer, veritabanında saklanıyor olsun. Sayfa her render edildiğinde veya her api çağrısında bu değerin veritabanından okunması gerekecektir. Biz memcached ile bu değeri her seferinde veritabanından okumak yerine önbellekte tutmak istiyor olalım.//Veritabanı bağlantıları vs.$memcache     = new Memcache;$memcache-&gt;connect('127.0.0.1', 11211) or die (\"Memcached ile bağlantı kurulamıyor\");$exampleValue = $memcache-&gt;get('exampleKey');if($exampleValue === true){\treturn $exampleValue;}else{\t$exampleValue = $db-&gt;get_var(sprintf(\"SELECT exampleValue FROM %s WHERE id = '%d'\",'exampleTable',1));\tif($exampleValue){\t\t$memcache-&gt;set('exampleKey', $exampleValue, false, 1800);\t\treturn $exampleValue;\t}\telse{\t\treturn false;\t}}Bu sayede veritabanından dolayı oluşacak disk i/o işlemleri azalacak, doğrudan bellek üzerinden erişilerek performans artışı sağlanabilecektir. Memcached’in doğru implement edilmesi, memcached üzerinde önbelleklenecek verilerin doğru seçilmesi ve yarış durumu oluşturabilecek işlemlerin önceden tespit edilmesi ile web sunucularında oluşabilecek yük azaltılabilecektir.",
            "content_html": "<p>Yüksek trafiğe sahip web sunucular, özellikle CRUD işlemlerinin fazla olduğu web sunucular, yüksek trafik sonucunda çok fazla yük altına girecektir. Böyle bir durumda, kod kaynakları yeterince verimli kullanabilecek şekilde yazılmışsa, ağır yük altında hizmet verebilmek için ilk ihtiyaç duyulanlardan biri, bir önbellek mekanizmasıdır.</p><p>Memcahced nedir?</p><p>Memcached 2003 yılında, alanının ilklerinden olan popüler blog servisi LiveJournal için yazılmış ve sonrasında özellikle web uygulamalarında çokça kullanılmaya başlanmış ücretiz, açık kaynak, yüksek performanslı ve dağıtık bir önbellekleme sistemidir. Basit ama güçlü bir önbellekleme sistemidir. Günümüzde Facebook tarafından aktif olarak kullanılmakta ve geliştirilmesine katkı sunulmaktadır. Yine popüler web uygulama ve servisleri tarafından (Wikipedia, Youtube, Flickr) aktif olarak kullanılmaktadır.</p><p>Memcached bir in-memory storedur. Tüm önbellekleme hafıza(ram) üzerindedir. Dolayısıyla kritik verilerin yalnızca memcached üzerinde saklanmaması gerekir. Memcached üzerinde veri, key-value çiftleri olarak saklanır. Memcached özellikle veritabanı işlemlerinin fazla olduğu web uygulamalarında hayat kurtarıcıdır.</p><p>Memcached Kurulum</p><p>Debian tabanlı Linux dağıtımlarında;</p><figure class=\"highlight\"><pre><code class=\"language-bash\" data-lang=\"bash\">apt-get <span class=\"nb\">install </span>php-memcachedapt-get <span class=\"nb\">install </span>memcached</code></pre></figure><p>RedHat/Fedora tabanlı Linux dağıtımlarında;</p><figure class=\"highlight\"><pre><code class=\"language-bash\" data-lang=\"bash\">yum <span class=\"nb\">install </span>php-memcachedyum <span class=\"nb\">install </span>memcached</code></pre></figure><p>komutu ile Memcached ve Php-Memcached paketleri kolayca kurulabilir. Memcached TCP/IP tabanlıdır. Herhangi iki yazılım arasında memcached ile haberleşme sağlanabilir.</p><p>Memcached’i başlatmak için</p><figure class=\"highlight\"><pre><code class=\"language-bash\" data-lang=\"bash\">memcached <span class=\"nt\">-d</span> <span class=\"nt\">-m</span> 512 <span class=\"nt\">-l</span> 127.0.0.1 <span class=\"nt\">-p</span> 11211 <span class=\"nt\">-u</span> nobody</code></pre></figure><p>komutu kullanılabilir. Bu komut ile, 512 MB bir önbellek alanı kullanan, 11211 tcp ve udp portunu dinleyen bir memcached servisi başlatılacaktır. Memcached servisi başlatılırken oluşturulan önbellek alanı sabittir. İşletim sistemi mimarilerindeki bellek yönetimine benzer şekilde, eğer önbellek alanı dolduysa ilk yazılan verinin üzerine yazacaktır. Memcached için x86 sistemlerde maksimum 4GB önbellek alanı tanımlayabilirsiniz.</p><p>Memcached başlatıldıktan sonra servisle ilgili daha fazla detay almak için;</p><figure class=\"highlight\"><pre><code class=\"language-bash\" data-lang=\"bash\"><span class=\"nb\">echo</span> <span class=\"s2\">\"stats settings\"</span> | nc localhost 11211</code></pre></figure><p>komutunu kullanabilirsiniz. Varsayılan olarak, Memcached key uzunlukları 250 karakterdir. Value ise maksimum 1MB olabilir.</p><p>PHP Memcached Kullanımı</p><p>PHP ile memcached’e bağlanmak için;</p><figure class=\"highlight\"><pre><code class=\"language-php\" data-lang=\"php\"><span class=\"nv\">$memcache</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Memcache</span><span class=\"p\">;</span><span class=\"nv\">$memcache</span><span class=\"o\">-&gt;</span><span class=\"nf\">connect</span><span class=\"p\">(</span><span class=\"s1\">'127.0.0.1'</span><span class=\"p\">,</span> <span class=\"mi\">11211</span><span class=\"p\">)</span> <span class=\"k\">or</span> <span class=\"k\">die</span> <span class=\"p\">(</span><span class=\"s2\">\"Memcached ile bağlantı kurulamıyor\"</span><span class=\"p\">);</span></code></pre></figure><p>Memcached üzerine veri yazmak için;</p><figure class=\"highlight\"><pre><code class=\"language-php\" data-lang=\"php\"><span class=\"nv\">$exampleValue</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">;</span><span class=\"nv\">$exampleValue</span> <span class=\"o\">=</span> <span class=\"s1\">'Example String'</span><span class=\"p\">;</span><span class=\"nv\">$exampleValue</span> <span class=\"o\">=</span> <span class=\"k\">array</span><span class=\"p\">(</span><span class=\"s1\">'0'</span><span class=\"p\">,</span><span class=\"s1\">'1'</span><span class=\"p\">,</span><span class=\"s1\">'2'</span><span class=\"p\">,</span><span class=\"s1\">'3'</span><span class=\"p\">);</span><span class=\"nv\">$memcache</span><span class=\"o\">-&gt;</span><span class=\"nf\">set</span><span class=\"p\">(</span><span class=\"s1\">'exampleKey'</span><span class=\"p\">,</span> <span class=\"nv\">$exampleValue</span><span class=\"p\">,</span> <span class=\"kc\">false</span><span class=\"p\">,</span> <span class=\"mi\">1800</span><span class=\"p\">);</span><span class=\"c1\">//Birinci parametre anahtar, ikinci parametre değer, üçüncü parametre memcached sıkıştırma true/false, dördüncü parametre saniye cinsinden önbellekleme süresi</span></code></pre></figure><p>Memcached üzerindeki bir anahtarın değerine ulaşmak için;</p><figure class=\"highlight\"><pre><code class=\"language-php\" data-lang=\"php\"><span class=\"nv\">$exampleValue</span> <span class=\"o\">=</span> <span class=\"nv\">$memcache</span><span class=\"o\">-&gt;</span><span class=\"nf\">get</span><span class=\"p\">(</span><span class=\"s1\">'exampleKey'</span><span class=\"p\">);</span></code></pre></figure><p>Örnek bir senaryoda, web uygulamamızdaki çok sık değişmeyen bir değer, veritabanında saklanıyor olsun. Sayfa her render edildiğinde veya her api çağrısında bu değerin veritabanından okunması gerekecektir. Biz memcached ile bu değeri her seferinde veritabanından okumak yerine önbellekte tutmak istiyor olalım.</p><figure class=\"highlight\"><pre><code class=\"language-php\" data-lang=\"php\"><span class=\"c1\">//Veritabanı bağlantıları vs.</span><span class=\"nv\">$memcache</span>     <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Memcache</span><span class=\"p\">;</span><span class=\"nv\">$memcache</span><span class=\"o\">-&gt;</span><span class=\"nf\">connect</span><span class=\"p\">(</span><span class=\"s1\">'127.0.0.1'</span><span class=\"p\">,</span> <span class=\"mi\">11211</span><span class=\"p\">)</span> <span class=\"k\">or</span> <span class=\"k\">die</span> <span class=\"p\">(</span><span class=\"s2\">\"Memcached ile bağlantı kurulamıyor\"</span><span class=\"p\">);</span><span class=\"nv\">$exampleValue</span> <span class=\"o\">=</span> <span class=\"nv\">$memcache</span><span class=\"o\">-&gt;</span><span class=\"nf\">get</span><span class=\"p\">(</span><span class=\"s1\">'exampleKey'</span><span class=\"p\">);</span><span class=\"k\">if</span><span class=\"p\">(</span><span class=\"nv\">$exampleValue</span> <span class=\"o\">===</span> <span class=\"kc\">true</span><span class=\"p\">){</span>\t<span class=\"k\">return</span> <span class=\"nv\">$exampleValue</span><span class=\"p\">;</span><span class=\"p\">}</span><span class=\"k\">else</span><span class=\"p\">{</span>\t<span class=\"nv\">$exampleValue</span> <span class=\"o\">=</span> <span class=\"nv\">$db</span><span class=\"o\">-&gt;</span><span class=\"nf\">get_var</span><span class=\"p\">(</span><span class=\"nb\">sprintf</span><span class=\"p\">(</span><span class=\"s2\">\"SELECT exampleValue FROM %s WHERE id = '%d'\"</span><span class=\"p\">,</span><span class=\"s1\">'exampleTable'</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">));</span>\t<span class=\"k\">if</span><span class=\"p\">(</span><span class=\"nv\">$exampleValue</span><span class=\"p\">){</span>\t\t<span class=\"nv\">$memcache</span><span class=\"o\">-&gt;</span><span class=\"nf\">set</span><span class=\"p\">(</span><span class=\"s1\">'exampleKey'</span><span class=\"p\">,</span> <span class=\"nv\">$exampleValue</span><span class=\"p\">,</span> <span class=\"kc\">false</span><span class=\"p\">,</span> <span class=\"mi\">1800</span><span class=\"p\">);</span>\t\t<span class=\"k\">return</span> <span class=\"nv\">$exampleValue</span><span class=\"p\">;</span>\t<span class=\"p\">}</span>\t<span class=\"k\">else</span><span class=\"p\">{</span>\t\t<span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"p\">;</span>\t<span class=\"p\">}</span><span class=\"p\">}</span></code></pre></figure><p>Bu sayede veritabanından dolayı oluşacak disk i/o işlemleri azalacak, doğrudan bellek üzerinden erişilerek performans artışı sağlanabilecektir. Memcached’in doğru implement edilmesi, memcached üzerinde önbelleklenecek verilerin doğru seçilmesi ve yarış durumu oluşturabilecek işlemlerin önceden tespit edilmesi ile web sunucularında oluşabilecek yük azaltılabilecektir.</p>",
            "url": "https://hakan.io/memcached-kurulumu-ve-php-memcache-kullanimi/",
            
            
            
            "tags": ["memcached","php","memcache","kullanim","ornek"],
            
            "date_published": "2018-08-20T03:22:16+03:00",
            "date_modified": "2018-08-20T03:22:16+03:00",
            
                "author": "Hakan"
            
        },
    
        {
            "id": "https://hakan.io/makine-ogrenmesi-turkce-haber-metinleri-veri-seti/",
            "title": "Makine Öğrenmesi - Türkçe Haber Metinleri Veri Seti",
            "summary": null,
            "content_text": "Türkçe haberler üzerinde çalışan bir sınıflandırıcı için bir süredir Türkçe haber metinleri biriktiriyorum. Geliştirdiğim crawler, farklı kaynaklardan toplamda 50.000’in üzerinde haber biriktirdi ve biriktirmeye devam ediyor. Bu alanda çalışan araştırmacıların güncel veri setlerine erişim zorluğu yaşaması sebebiyle 5 farklı kategoriye ayrılmış toplamda 500 Türkçe haber metnine aşağıdaki bağlantıdan ulaşabilirsiniz.Veri setinde bulunan haberler, kelime frekanslarını kullanan bir özetleme sistemi vasıtasıyla özetlenmiştir. Haberler;  Ekonomi  Politika  Sanat  Spor  Teknoloji olarak kategorilere ayrılmıştır ve her bir kategoriye ait haberler farklı tablolarda bulunmaktadır. Haberler başlık, özet metin, kaynak ve zaman damgası bilgilerini içermektedir.İlgili veri seti",
            "content_html": "<p>Türkçe haberler üzerinde çalışan bir sınıflandırıcı için bir süredir Türkçe haber metinleri biriktiriyorum. Geliştirdiğim crawler, farklı kaynaklardan toplamda 50.000’in üzerinde haber biriktirdi ve biriktirmeye devam ediyor. Bu alanda çalışan araştırmacıların güncel veri setlerine erişim zorluğu yaşaması sebebiyle 5 farklı kategoriye ayrılmış toplamda 500 Türkçe haber metnine aşağıdaki bağlantıdan ulaşabilirsiniz.</p><p>Veri setinde bulunan haberler, kelime frekanslarını kullanan bir özetleme sistemi vasıtasıyla özetlenmiştir. Haberler;</p><ul>  <li>Ekonomi</li>  <li>Politika</li>  <li>Sanat</li>  <li>Spor</li>  <li>Teknoloji olarak kategorilere ayrılmıştır ve her bir kategoriye ait haberler farklı tablolarda bulunmaktadır. Haberler başlık, özet metin, kaynak ve zaman damgası bilgilerini içermektedir.</li></ul><p><a href=\"https://hakan.io/assets/files/dataset/news.sql\">İlgili veri seti</a></p>",
            "url": "https://hakan.io/makine-ogrenmesi-turkce-haber-metinleri-veri-seti/",
            
            
            
            "tags": ["makine öğrenmesi","türkçe haber metinleri","veri seti"],
            
            "date_published": "2018-08-02T03:02:42+03:00",
            "date_modified": "2018-08-02T03:02:42+03:00",
            
                "author": "Hakan"
            
        },
    
        {
            "id": "https://hakan.io/email-adres-formati-php-filter-var-fonksiyonu-ve-rfc-5321/",
            "title": "Email Adres Formatı, PHP filter_var Fonksiyonu ve RFC 5321",
            "summary": null,
            "content_text": "Email adres formatı Rfc 5321 ile belirlenmiş durumda. Fakat pratikte işler biraz değişiyor. Rfc5321 bir email adresinin şu şekilde olabileceğini bize söylüyor.local-part@domainDomain bölümü herhangi bir domain veya sub-domain olabilir, hatta tld olmayan local bir domain de olabilir. Fakat local-part bölümü için şu kısıtlar var.  A-Z, a-z latin karakterler  0-9 rakamlar  İlk ve son karakter olmamak kaydıyla nokta (.) karakteri                              Özel karakterler !#$%&amp;’*+-/=?^_`{          }~                    Özel karakterler arasında - ve _ karakterlerine aşinayız fakat diğer özel karakterler hiç yaygın değil. Popüler email servislerinden Google’ın email servisi özel karakterlere izin vermezken, Microsoft’un email servisi ise yalnızca - ve _ özel karakterlerine izin veriyor. Farklı bir servis için ise şöyle bir adres mümkün olabilir.john`doe{software-developer}@domain.sub-domain.comPHP filter_var fonksiyonu ile email adres formatının kontrolü sağlandığındafilter_var('john`doe{software-developer}@domain.sub-domain.com',FILTER_VALIDATE_EMAIL)bize Rfc 5321’de açıklanan formata uyduğu için false bir değer döndürmeyecek ancak domain bölümünün gmail olması durumunda, gmail implementasyonu farklı olduğu için olmaması gereken bir email adresini doğru kabul etmiş olacağız. Standart dışı bir kütüphane veya farklı bir yöntemle doğrulama yapmaya çalışıldığı zaman ise işler iyice içinden çıkılmaz bir hal alacaktır. Olası bir senaryoda, popüler email servislerine yönelik bir doğrulama Rfc 5321’e göre uygulanmış bir başka email servisi için hatalı sonuç verecektir. Çok dilli bir sistemde, bölgesel ve farklı dillerde kullanılan email servislerinin olması durumunda ise sonuç tam anlamıyla facia!",
            "content_html": "<p>Email adres formatı Rfc 5321 ile belirlenmiş durumda. Fakat pratikte işler biraz değişiyor. Rfc5321 bir email adresinin şu şekilde olabileceğini bize söylüyor.</p><p>local-part@domain</p><p>Domain bölümü herhangi bir domain veya sub-domain olabilir, hatta tld olmayan local bir domain de olabilir. Fakat local-part bölümü için şu kısıtlar var.</p><ul>  <li>A-Z, a-z latin karakterler</li>  <li>0-9 rakamlar</li>  <li>İlk ve son karakter olmamak kaydıyla nokta (.) karakteri</li>  <li>    <table>      <tbody>        <tr>          <td>Özel karakterler !#$%&amp;’*+-/=?^_`{</td>          <td>}~</td>        </tr>      </tbody>    </table>  </li></ul><p>Özel karakterler arasında - ve _ karakterlerine aşinayız fakat diğer özel karakterler hiç yaygın değil. Popüler email servislerinden Google’ın email servisi özel karakterlere izin vermezken, Microsoft’un email servisi ise yalnızca - ve _ özel karakterlerine izin veriyor. Farklı bir servis için ise şöyle bir adres mümkün olabilir.</p><figure class=\"highlight\"><pre><code class=\"language-php\" data-lang=\"php\"><span class=\"n\">john</span><span class=\"err\">`</span><span class=\"n\">doe</span><span class=\"p\">{</span><span class=\"n\">software</span><span class=\"o\">-</span><span class=\"n\">developer</span><span class=\"p\">}</span><span class=\"o\">@</span><span class=\"n\">domain</span><span class=\"mf\">.</span><span class=\"n\">sub</span><span class=\"o\">-</span><span class=\"n\">domain</span><span class=\"mf\">.</span><span class=\"n\">com</span></code></pre></figure><p>PHP filter_var fonksiyonu ile email adres formatının kontrolü sağlandığında</p><figure class=\"highlight\"><pre><code class=\"language-php\" data-lang=\"php\"><span class=\"nb\">filter_var</span><span class=\"p\">(</span><span class=\"s1\">'john`doe{software-developer}@domain.sub-domain.com'</span><span class=\"p\">,</span><span class=\"no\">FILTER_VALIDATE_EMAIL</span><span class=\"p\">)</span></code></pre></figure><p>bize Rfc 5321’de açıklanan formata uyduğu için false bir değer döndürmeyecek ancak domain bölümünün gmail olması durumunda, gmail implementasyonu farklı olduğu için olmaması gereken bir email adresini doğru kabul etmiş olacağız. Standart dışı bir kütüphane veya farklı bir yöntemle doğrulama yapmaya çalışıldığı zaman ise işler iyice içinden çıkılmaz bir hal alacaktır. Olası bir senaryoda, popüler email servislerine yönelik bir doğrulama Rfc 5321’e göre uygulanmış bir başka email servisi için hatalı sonuç verecektir. Çok dilli bir sistemde, bölgesel ve farklı dillerde kullanılan email servislerinin olması durumunda ise sonuç tam anlamıyla facia!</p>",
            "url": "https://hakan.io/email-adres-formati-php-filter-var-fonksiyonu-ve-rfc-5321/",
            
            
            
            "tags": ["email adres formatı","php filter_var fonksiyonu","rfc 5321"],
            
            "date_published": "2018-07-07T03:15:06+03:00",
            "date_modified": "2018-07-07T03:15:06+03:00",
            
                "author": "Hakan"
            
        },
    
        {
            "id": "https://hakan.io/apple-mac-bilgisayarlarda-kendi-tasarladigi-islemcileri-kullanacak/",
            "title": "Apple Mac Bilgisayarlarda Kendi Tasarladığı İşlemcileri Kullanacak",
            "summary": null,
            "content_text": "Intel’in Meltdown ve Spectre işlemci zafiyetleri sonrasında Apple’ın Mac bilgisayarlarda kendi işlemcilerini kullanmayı planladığı ileri sürüldü. İddiaya göre Apple 2020 yılında masaüstü ve dizüstü bilgisayarlarda kendi ürettiği işlemcileri kullanmaya başlayacak. Bloomberg’in raporuna göre Apple kendi tasarladığı ARM tabanlı işlemcileri kullanmayı düşünüyor.Apple halihazırda A serisi işlemcilerini iPhone, iPad modellerinde kullanıyor. Fakat masaüstü ve dizüstü serilerinde böyle önemli bir değişikliğin nasıl sonuçlar doğuracağı şimdilik bilinmiyor. Apple’ın bu hamlesinin Intel ve AMD işlemcilerde tarihin en büyük teknoloji kusurlarının keşfedilmesiyle ilgili olduğu aşikar.Apple daha önce de kendi üretimi işlemcileri kullanmıştı. PowerPC işlemciler 1991 yılından itibaren Apple cihazlarında kullanılmış ve 2006’da Intel işlemcilere tamamen geçilene kadar yüksek beğeni toplamıştı. Apple’ın ARM tabanlı kendi tasarım işlemcilerini kullanmaya başlamasıyla birlikte, iOS uygulamalarının da Mac cihazlarda çalışabilmesinin önü de açılacak.Apple bu geçiş ile birlikte kazancının %5 gibi önemli bir bölümünü Intel ile paylaşmak zorunda kalmayacak. Ancak müşterileri için özel teklifler de sunacak. Yüksek işlem gücüne ihtiyaç duyan Mac kullanıcıları için performans sorunlarının önüne bu şekilde geçilecek. Kendi işlemcilerine geçmek ise, Apple’ın kendi donanım yol haritasını çizmesini kolaylaştıracak gibi görünüyor.Apple’ın Intel’den vazgeçerek kendi tasarım işlemcilerini kullanacağı uzun yıllardır konuşulan bir durum. Geçtiğimiz aylarda yayınlanan bir raporda Apple’ın Intel işlemcilere olan güveninin azaldığı belirtilmişti. Ancak tüm bu söylenti ve iddialara Apple ve Intel tarafından henüz bir cevap gelmedi.",
            "content_html": "<p>Intel’in Meltdown ve Spectre işlemci zafiyetleri sonrasında Apple’ın Mac bilgisayarlarda kendi işlemcilerini kullanmayı planladığı ileri sürüldü. İddiaya göre Apple 2020 yılında masaüstü ve dizüstü bilgisayarlarda kendi ürettiği işlemcileri kullanmaya başlayacak. Bloomberg’in raporuna göre Apple kendi tasarladığı ARM tabanlı işlemcileri kullanmayı düşünüyor.</p><p>Apple halihazırda A serisi işlemcilerini iPhone, iPad modellerinde kullanıyor. Fakat masaüstü ve dizüstü serilerinde böyle önemli bir değişikliğin nasıl sonuçlar doğuracağı şimdilik bilinmiyor. Apple’ın bu hamlesinin Intel ve AMD işlemcilerde tarihin en büyük teknoloji kusurlarının keşfedilmesiyle ilgili olduğu aşikar.</p><p><img src=\"/assets/images/post/apple-custom-cpu-mac.jpg\" alt=\"Apple Mac Custom CPU\" title=\"Apple Mac Custom CPU\" /></p><p>Apple daha önce de kendi üretimi işlemcileri kullanmıştı. PowerPC işlemciler 1991 yılından itibaren Apple cihazlarında kullanılmış ve 2006’da Intel işlemcilere tamamen geçilene kadar yüksek beğeni toplamıştı. Apple’ın ARM tabanlı kendi tasarım işlemcilerini kullanmaya başlamasıyla birlikte, iOS uygulamalarının da Mac cihazlarda çalışabilmesinin önü de açılacak.</p><p>Apple bu geçiş ile birlikte kazancının %5 gibi önemli bir bölümünü Intel ile paylaşmak zorunda kalmayacak. Ancak müşterileri için özel teklifler de sunacak. Yüksek işlem gücüne ihtiyaç duyan Mac kullanıcıları için performans sorunlarının önüne bu şekilde geçilecek. Kendi işlemcilerine geçmek ise, Apple’ın kendi donanım yol haritasını çizmesini kolaylaştıracak gibi görünüyor.</p><p>Apple’ın Intel’den vazgeçerek kendi tasarım işlemcilerini kullanacağı uzun yıllardır konuşulan bir durum. Geçtiğimiz aylarda yayınlanan bir raporda Apple’ın Intel işlemcilere olan güveninin azaldığı belirtilmişti. Ancak tüm bu söylenti ve iddialara Apple ve Intel tarafından henüz bir cevap gelmedi.</p>",
            "url": "https://hakan.io/apple-mac-bilgisayarlarda-kendi-tasarladigi-islemcileri-kullanacak/",
            
            
            
            "tags": ["apple","mac"],
            
            "date_published": "2018-04-12T03:00:00+03:00",
            "date_modified": "2018-04-12T03:00:00+03:00",
            
                "author": "Hakan"
            
        },
    
        {
            "id": "https://hakan.io/mukemmel-sayilar-c-programlama-dili-ile-ornek-kodlar/",
            "title": "Mükemmel Sayılar - C Programlama Dili İle Örnek Kodlar",
            "summary": null,
            "content_text": "Mükemmel sayılar, kendisi hariç pozitif tam bölenlerinin toplamına eşit olan sayılardır. En küçük mükemmel sayı 6’dır.6’nın pozitif tam bölenleri: 1,2,3 ve 6 kendisi hariç tam bölenlerinin toplamı: 1+2+3 = 6’dır ve 6 bir mükemmel sayıdır.Yine aynı şekilde 28’in pozitif tam bölenleri: 1,2,4,7,14,28 kendisi hariç tam bölenlerinin toplamı: 1+2+4+7+14 = 28’dir ve 28 bir mükemmel sayıdır.Yeterince büyük bir sayının tam bölenlerinin tespit edilmesi için gereken zaman miktarı, bilgisayarın işlem gücüyle orantılı olacak şekilde değişecektir. Esasında tam bölenlerin bulunması için yapılacak işlem 1’den n’e kadar tüm tamsayıların n’in bir tam böleni olup olmadığının kontrolünden ibarettir. Mükemmel sayıları matematiksel olarak ifade etmek mümkündür. Öklid yaptığı çalışmalar neticesinde ilk dört asal sayı için bir formül keşfetmiştir. Sonrasında ise formülün -şimdiye kadar- hesaplanabilen tüm mükemmel sayılar için geçerli olduğu ispat edilmiştir. Daha doğru bir ifadeyle formülün geçersiz olduğu bir mükemmel sayı henüz keşfedilmemiştir.Mükemmel sayılar için keşfedilen formül p ve \\(2^p-1\\) sayıları asal sayı olmak koşuluyla şöyledir:\\[2^{p-1}(2^p-1)\\]p=2 için \\(2^1(2^2-1) = 6\\)p=3 için \\(2^2(2^3-1) = 28\\)p=5 için \\(2^4(2^5-1) = 496\\)Mükemmel sayılarla ilgili diğer bir formül ise, mükemmel bir sayının 1 hariç tüm pozitif tam bölenlerinin tersinin toplamı 1’e eşittir.6 için 1/2 + 1/3 + 1/6 = 128 için 1/2 + 1/4 + 1/7 + 1/14 + 1/28 = 1 olacaktır.Şimdiye kadar hesaplanabilen tüm mükemmel sayılar çifttir. Henüz keşfedilmiş tek mükemmel sayı yok. İlk on mükemmel sayı ise şöyledir;628496812833550336858986905613743869132823058430081399521282658455991569831744654692615953842176191561942608236107294793378084303638130997321548169216Mükemmel sayıların bulunması için C programlama dilinde yaklaşımımız, sayının tüm pozitif tam bölenlerini hesaplamak ve toplamak yönünde olacak. Dolayısıyla ilk 4 mükemmel sayı hızlı bir şekilde bulunabilse de, sonraki mükemmel sayılar için iterasyon bir hayli artacağı için hesaplama süresi de bir o kadar artacaktır. Geleneksel yöntemin haricinde her tam bölen bulunduktan sonra, sonraki bölenlerin bulunması sürecinde tekrar hesaplamak yerine işaretleyerek, algoritmayı geliştirmek ve işlem süresini kısaltmak mümkün.Mükemmel sayıların bulunması için örnek bir C programı şöyle;#include &lt;stdio.h&gt;int main(){\t//1'den 10000'e kadar olan mukemmel \t//sayilari bulmaya calisiyoruz\tfor (int i=1; i &lt;10000 ; i++) {\t\t//Her sayi icin pozitif tam bolenlerini \t\t//bularak kendisi haric toplamini hesapliyoruz\t\tint sum = 0;\t\tfor(int j=1; j&lt;i; j++){\t\t\tif(i%j==0){\t\t\t\tsum = sum + j;\t\t\t}\t\t}\t\t//Kendisi haric pozitif tam bolenlerinin \t\t//toplami kendisine esit mi diye kontrol ediyoruz\t\tif(sum == i){\t\t\tprintf(\"%d\\n\",i );\t\t}\t}\t\treturn 0;}Herhangi bir sayının mükemmel sayı olup olmadığını kontrol eden örnek bir C programı ise şöyle olacaktır;#include &lt;stdio.h&gt;int main(){\tint sayi;\tprintf(\"Sayi? \\n\");\tscanf(\"%d\",&amp;sayi);\tint sum = 0;\tfor(int j=1; j&lt;sayi; j++){\t\tif(sayi%j==0){\t\t\tsum = sum + j;\t\t}\t}\tif(sum == sayi){\t\tprintf(\"%d bir mukemmel sayidir\\n\",sayi );\t}\telse{\t\tprintf(\"%d bir mukemmel sayi degildir\\n\",sayi );\t}\treturn 0;}",
            "content_html": "<p>Mükemmel sayılar, kendisi hariç pozitif tam bölenlerinin toplamına eşit olan sayılardır. En küçük mükemmel sayı 6’dır.</p><p>6’nın pozitif tam bölenleri: 1,2,3 ve 6 kendisi hariç tam bölenlerinin toplamı: 1+2+3 = 6’dır ve 6 bir mükemmel sayıdır.</p><p>Yine aynı şekilde 28’in pozitif tam bölenleri: 1,2,4,7,14,28 kendisi hariç tam bölenlerinin toplamı: 1+2+4+7+14 = 28’dir ve 28 bir mükemmel sayıdır.</p><p>Yeterince büyük bir sayının tam bölenlerinin tespit edilmesi için gereken zaman miktarı, bilgisayarın işlem gücüyle orantılı olacak şekilde değişecektir. Esasında tam bölenlerin bulunması için yapılacak işlem 1’den n’e kadar tüm tamsayıların n’in bir tam böleni olup olmadığının kontrolünden ibarettir. Mükemmel sayıları matematiksel olarak ifade etmek mümkündür. Öklid yaptığı çalışmalar neticesinde ilk dört asal sayı için bir formül keşfetmiştir. Sonrasında ise formülün -şimdiye kadar- hesaplanabilen tüm mükemmel sayılar için geçerli olduğu ispat edilmiştir. Daha doğru bir ifadeyle formülün geçersiz olduğu bir mükemmel sayı henüz keşfedilmemiştir.</p><p>Mükemmel sayılar için keşfedilen formül p ve \\(2^p-1\\) sayıları asal sayı olmak koşuluyla şöyledir:</p>\\[2^{p-1}(2^p-1)\\]<p>p=2 için \\(2^1(2^2-1) = 6\\)</p><p>p=3 için \\(2^2(2^3-1) = 28\\)</p><p>p=5 için \\(2^4(2^5-1) = 496\\)</p><p>Mükemmel sayılarla ilgili diğer bir formül ise, mükemmel bir sayının 1 hariç tüm pozitif tam bölenlerinin tersinin toplamı 1’e eşittir.</p><p>6 için 1/2 + 1/3 + 1/6 = 1</p><p>28 için 1/2 + 1/4 + 1/7 + 1/14 + 1/28 = 1 olacaktır.</p><p>Şimdiye kadar hesaplanabilen tüm mükemmel sayılar çifttir. Henüz keşfedilmiş tek mükemmel sayı yok. İlk on mükemmel sayı ise şöyledir;</p><p>6</p><p>28</p><p>496</p><p>8128</p><p>33550336</p><p>8589869056</p><p>137438691328</p><p>2305843008139952128</p><p>2658455991569831744654692615953842176</p><p>191561942608236107294793378084303638130997321548169216</p><p>Mükemmel sayıların bulunması için C programlama dilinde yaklaşımımız, sayının tüm pozitif tam bölenlerini hesaplamak ve toplamak yönünde olacak. Dolayısıyla ilk 4 mükemmel sayı hızlı bir şekilde bulunabilse de, sonraki mükemmel sayılar için iterasyon bir hayli artacağı için hesaplama süresi de bir o kadar artacaktır. Geleneksel yöntemin haricinde her tam bölen bulunduktan sonra, sonraki bölenlerin bulunması sürecinde tekrar hesaplamak yerine işaretleyerek, algoritmayı geliştirmek ve işlem süresini kısaltmak mümkün.</p><p>Mükemmel sayıların bulunması için örnek bir C programı şöyle;</p><figure class=\"highlight\"><pre><code class=\"language-c\" data-lang=\"c\"><span class=\"cp\">#include &lt;stdio.h&gt;</span><span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">(){</span>\t<span class=\"c1\">//1'den 10000'e kadar olan mukemmel </span>\t<span class=\"c1\">//sayilari bulmaya calisiyoruz</span>\t<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span><span class=\"mi\">10000</span> <span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\t\t<span class=\"c1\">//Her sayi icin pozitif tam bolenlerini </span>\t\t<span class=\"c1\">//bularak kendisi haric toplamini hesapliyoruz</span>\t\t<span class=\"kt\">int</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\t\t<span class=\"k\">for</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"n\">j</span><span class=\"o\">&lt;</span><span class=\"n\">i</span><span class=\"p\">;</span> <span class=\"n\">j</span><span class=\"o\">++</span><span class=\"p\">){</span>\t\t\t<span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"o\">%</span><span class=\"n\">j</span><span class=\"o\">==</span><span class=\"mi\">0</span><span class=\"p\">){</span>\t\t\t\t<span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"n\">sum</span> <span class=\"o\">+</span> <span class=\"n\">j</span><span class=\"p\">;</span>\t\t\t<span class=\"p\">}</span>\t\t<span class=\"p\">}</span>\t\t<span class=\"c1\">//Kendisi haric pozitif tam bolenlerinin </span>\t\t<span class=\"c1\">//toplami kendisine esit mi diye kontrol ediyoruz</span>\t\t<span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">sum</span> <span class=\"o\">==</span> <span class=\"n\">i</span><span class=\"p\">){</span>\t\t\t<span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"%d</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">,</span><span class=\"n\">i</span> <span class=\"p\">);</span>\t\t<span class=\"p\">}</span>\t<span class=\"p\">}</span>\t\t<span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"p\">}</span></code></pre></figure><p>Herhangi bir sayının mükemmel sayı olup olmadığını kontrol eden örnek bir C programı ise şöyle olacaktır;</p><figure class=\"highlight\"><pre><code class=\"language-c\" data-lang=\"c\"><span class=\"cp\">#include &lt;stdio.h&gt;</span><span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">(){</span>\t<span class=\"kt\">int</span> <span class=\"n\">sayi</span><span class=\"p\">;</span>\t<span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"Sayi? </span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">);</span>\t<span class=\"n\">scanf</span><span class=\"p\">(</span><span class=\"s\">\"%d\"</span><span class=\"p\">,</span><span class=\"o\">&amp;</span><span class=\"n\">sayi</span><span class=\"p\">);</span>\t<span class=\"kt\">int</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\t<span class=\"k\">for</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"n\">j</span><span class=\"o\">&lt;</span><span class=\"n\">sayi</span><span class=\"p\">;</span> <span class=\"n\">j</span><span class=\"o\">++</span><span class=\"p\">){</span>\t\t<span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">sayi</span><span class=\"o\">%</span><span class=\"n\">j</span><span class=\"o\">==</span><span class=\"mi\">0</span><span class=\"p\">){</span>\t\t\t<span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"n\">sum</span> <span class=\"o\">+</span> <span class=\"n\">j</span><span class=\"p\">;</span>\t\t<span class=\"p\">}</span>\t<span class=\"p\">}</span>\t<span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">sum</span> <span class=\"o\">==</span> <span class=\"n\">sayi</span><span class=\"p\">){</span>\t\t<span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"%d bir mukemmel sayidir</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">,</span><span class=\"n\">sayi</span> <span class=\"p\">);</span>\t<span class=\"p\">}</span>\t<span class=\"k\">else</span><span class=\"p\">{</span>\t\t<span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"%d bir mukemmel sayi degildir</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">,</span><span class=\"n\">sayi</span> <span class=\"p\">);</span>\t<span class=\"p\">}</span>\t<span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"p\">}</span></code></pre></figure>",
            "url": "https://hakan.io/mukemmel-sayilar-c-programlama-dili-ile-ornek-kodlar/",
            
            
            
            "tags": ["mükemmel sayı","mükemmel sayılar","c ile mükemmel sayı","c programlama mükemmel sayılar","mükemmel sayılar örnek kod","mükemmel sayı fonksiyon"],
            
            "date_published": "2018-03-25T03:15:12+03:00",
            "date_modified": "2018-03-25T03:15:12+03:00",
            
                "author": "Hakan"
            
        },
    
        {
            "id": "https://hakan.io/meltdown-ve-spectre-islemci-zafiyetleri/",
            "title": "Meltdown ve Spectre İşlemci Zafiyetleri",
            "summary": null,
            "content_text": "Yeni yılın ilk günleri ile birlikte çok büyük ölçekteki iki güvenlik açığı duyuruldu. Neredeyse şu anda kullanımda olan tüm bilgisayarları, akıllı telefonları, tablet bilgisayarları ve sunucuları etkileyen güvenlik açığı ile parolalarınınız ve hassas verileriniz tehlike altında.Google Project Zero ekibi tarafından keşfedilen ve duyurulan güvenlik açığı tüm işlemcileri (Intel, AMD, ARM) ve tüm cihazları etkiliyor. Donanım düzeyindeki bu zafiyet iki saldırı olarak kategorilendi. Meltdown ve Spectre.İki saldırı da modern işlemcilerin performansı artırmak için kullandığı yöntemleri kendi lehine kullanıyor.Meltdownİlk olarak Meltdown atağı ile saldırgan, hedef makinanın tüm fiziksel hafızasını okuyabiliyor. Bu da diğer programlar ve işletim sistemi tarafından kullanılan tüm hassas verilerin ve parolaların okunabileceği anlamına geliyor.Meltdown, kullanıcı uygulamaları ve işletim sistemi arasındaki izolasyonu kırmak için spekülatif çalıştırma özelliğini kullanıyor ve herhangi bir uygulamanın çekirdek için ayrılan bellek de dahil olmak üzere tüm sistem belleğine erişmesine izin veriyor.Meltdown, Intel işlemcilere özgü bir ayrıcalık yükseltme açığından faydalanıyor. Bu da bellek korumasının aşılmasına neden oluyor.Güvenlik açığının tüm işlemcileri etkilemesinin sebebi çok temel düzeyde bir problem olması. İşletim sistemi mimarilerinde işletim sistemi çekirdeği ile kullanıcı programları bellek üzerinde bir arada bulunur. Bu da böyle bir güvenlik açığına sebep oluyor. Bu durumu önlemenin yolu işletim sistemi çekirdeği ile kullanıcı programlarını farklı page tablelar üzerinde tutmak, kısaca işletim sistemi çekirdeğini ve kullanıcı programlarını izole etmek. Sorunun çözümü basit fakat her sistem çağrısında page tableların yeniden yüklenmesi gerekiyor ve yama sonuç olarak, yapılan testlere göre %5 – %30 arasında bir performans kaybına sebep olacak.Spectreİkinci olarak iste Spectre atağı ile saldırgan tarafından geliştirilen bir program, sistemde çalışırken diğer programların kendi belleklerinin rastgele bölümlerine erişmesine izin vererek veri sızıntısına yol açıyor ve bir yan kanaldan veriyi okuyabiliyor.Spectre ile meydana gelen güvenlik açığını yamamak pek kolay görünmüyor. Bu zafiyetin tamamen ortadan kaldırılması için işlemci mimarilerinde köklü değişiklikler yapılması gerekmekte ve bu uzun bir süreç anlamına geliyor.Zafiyet Intel, AMD, ARM işlemcilerini kullanan masaüstü ve taşınabilir bilgisayarlar, sunucular, akıllı telefonlar dahil tüm sistemleri etkiliyor. Öte yandan internet tarayıcıları tarafında Javascript ile zafiyetten faydalanılması mümkün ve bu durum tüm internet kullanıcılarının hassas verilerinin ve parolalarının güvende olmadığı anlamına geliyor.Google Project Zero ekibi tarafından keşfedilen ve duyurulan güvenlik açıkları zero day kapsamında çoğu işlemci üreticisi ve işletim sistemi tarafından ciddiyetle karşılandı ve duyurulmadan önce gerekli yamalar hazırlandı.Nasıl Önlem Alınır?Kimler etkilendi? – Kısaca herkes!Windows : Microsoft Windows 10 için bir yama yayınladı. Diğer Windows sürümleri için 9 Ocak’ta bir yama yayınlanacak.MacOS : Apple bu güvenlik açıklarının büyük bir kısmını geçen ay yayınlanan High Sierra 10.13.2’de düzeltmişti. High Sierra 10.13.3 sürüm güncellemesi ile eksik kalan kısımları da yamayacak.Linux :  Linux çekirdekleri için, çekirdeği tamamen ayrı bir adres alanına taşıyacak olan kernel page table isolation (KPTI) içeren yamaları yayınlandı.Android :  Google Pixel ve Nexus kullanıcıları için güvenlik yamalarını içeren güncelleme yayınladı. Diğer marka model cihaz kullanıcıları ise üreticilerinin bir güvenlik yaması yayınlamasını beklemek zorunda.",
            "content_html": "<p>Yeni yılın ilk günleri ile birlikte çok büyük ölçekteki iki güvenlik açığı duyuruldu. Neredeyse şu anda kullanımda olan tüm bilgisayarları, akıllı telefonları, tablet bilgisayarları ve sunucuları etkileyen güvenlik açığı ile parolalarınınız ve hassas verileriniz tehlike altında.</p><p>Google Project Zero ekibi tarafından keşfedilen ve duyurulan güvenlik açığı tüm işlemcileri (Intel, AMD, ARM) ve tüm cihazları etkiliyor. Donanım düzeyindeki bu zafiyet iki saldırı olarak kategorilendi. Meltdown ve Spectre.</p><p>İki saldırı da modern işlemcilerin performansı artırmak için kullandığı yöntemleri kendi lehine kullanıyor.</p><p><strong>Meltdown</strong></p><p>İlk olarak Meltdown atağı ile saldırgan, hedef makinanın tüm fiziksel hafızasını okuyabiliyor. Bu da diğer programlar ve işletim sistemi tarafından kullanılan tüm hassas verilerin ve parolaların okunabileceği anlamına geliyor.</p><p>Meltdown, kullanıcı uygulamaları ve işletim sistemi arasındaki izolasyonu kırmak için spekülatif çalıştırma özelliğini kullanıyor ve herhangi bir uygulamanın çekirdek için ayrılan bellek de dahil olmak üzere tüm sistem belleğine erişmesine izin veriyor.</p><p>Meltdown, Intel işlemcilere özgü bir ayrıcalık yükseltme açığından faydalanıyor. Bu da bellek korumasının aşılmasına neden oluyor.</p><p>Güvenlik açığının tüm işlemcileri etkilemesinin sebebi çok temel düzeyde bir problem olması. İşletim sistemi mimarilerinde işletim sistemi çekirdeği ile kullanıcı programları bellek üzerinde bir arada bulunur. Bu da böyle bir güvenlik açığına sebep oluyor. Bu durumu önlemenin yolu işletim sistemi çekirdeği ile kullanıcı programlarını farklı page tablelar üzerinde tutmak, kısaca işletim sistemi çekirdeğini ve kullanıcı programlarını izole etmek. Sorunun çözümü basit fakat her sistem çağrısında page tableların yeniden yüklenmesi gerekiyor ve yama sonuç olarak, yapılan testlere göre %5 – %30 arasında bir performans kaybına sebep olacak.</p><p><strong>Spectre</strong></p><p>İkinci olarak iste Spectre atağı ile saldırgan tarafından geliştirilen bir program, sistemde çalışırken diğer programların kendi belleklerinin rastgele bölümlerine erişmesine izin vererek veri sızıntısına yol açıyor ve bir yan kanaldan veriyi okuyabiliyor.</p><p>Spectre ile meydana gelen güvenlik açığını yamamak pek kolay görünmüyor. Bu zafiyetin tamamen ortadan kaldırılması için işlemci mimarilerinde köklü değişiklikler yapılması gerekmekte ve bu uzun bir süreç anlamına geliyor.</p><p>Zafiyet Intel, AMD, ARM işlemcilerini kullanan masaüstü ve taşınabilir bilgisayarlar, sunucular, akıllı telefonlar dahil tüm sistemleri etkiliyor. Öte yandan internet tarayıcıları tarafında Javascript ile zafiyetten faydalanılması mümkün ve bu durum tüm internet kullanıcılarının hassas verilerinin ve parolalarının güvende olmadığı anlamına geliyor.</p><p>Google Project Zero ekibi tarafından keşfedilen ve duyurulan güvenlik açıkları zero day kapsamında çoğu işlemci üreticisi ve işletim sistemi tarafından ciddiyetle karşılandı ve duyurulmadan önce gerekli yamalar hazırlandı.</p><p>Nasıl Önlem Alınır?</p><p>Kimler etkilendi? – Kısaca herkes!</p><p><strong>Windows :</strong> Microsoft Windows 10 için bir yama yayınladı. Diğer Windows sürümleri için 9 Ocak’ta bir yama yayınlanacak.</p><p><strong>MacOS :</strong> Apple bu güvenlik açıklarının büyük bir kısmını geçen ay yayınlanan High Sierra 10.13.2’de düzeltmişti. High Sierra 10.13.3 sürüm güncellemesi ile eksik kalan kısımları da yamayacak.</p><p><strong>Linux :</strong>  Linux çekirdekleri için, çekirdeği tamamen ayrı bir adres alanına taşıyacak olan kernel page table isolation (KPTI) içeren yamaları yayınlandı.</p><p><strong>Android :</strong>  Google Pixel ve Nexus kullanıcıları için güvenlik yamalarını içeren güncelleme yayınladı. Diğer marka model cihaz kullanıcıları ise üreticilerinin bir güvenlik yaması yayınlamasını beklemek zorunda.</p>",
            "url": "https://hakan.io/meltdown-ve-spectre-islemci-zafiyetleri/",
            
            
            
            "tags": ["meltdown","spectre","zafiyet","işlemci zafiyet"],
            
            "date_published": "2018-01-04T03:00:00+03:00",
            "date_modified": "2018-01-04T03:00:00+03:00",
            
                "author": "Hakan"
            
        },
    
        {
            "id": "https://hakan.io/apple-iphone-x-face-id-maske-kullanilarak-asildi/",
            "title": "Apple iPhone X Face ID Maske Kullanılarak Aşıldı",
            "summary": null,
            "content_text": "Apple Iphone serisinin en son duyurulan modeli iPhone X ile birlikte gelen yeni güvenlik altyapısı Face ID, güvenlik araştırmacıları tarafından kırıldı. Toplamda 150$’dan daha az bir maliyetle geliştirilen maske ile cihazın kilidi açıldı.Apple Face ID teknolojisini ultra güvenli olarak duyurmuştu. Fakat siber güvenlik firması Bkav araştırmacıları; cihaz sahibinin yüzünü 3 boyutlu yazıcı ile basılan maske, 2 boyutlu fotoğraf ve biraz makyaj ile silikondan tekrar oluşturdu. Oluşturulan maske ile iPhone X Face ID teknolojisi cihazın gerçek sahibiymiş gibi kandırıldı ve cihaza erişim sağlanmış oldu.Dünya’da bir çok kullanıcı ve araştırmacı tarafından yapılan maskeler kullanılarak ve farklı yöntemlerle Face ID aşılmaya çalışıldı fakat hiçbiri başarılı olamadı. Bunun nedeni Face ID’nin yapay zekasının nasıl çalıştığının tam olarak anlaşılamamış olmasıydı.iPhone X ekran kilidinin açılması için, telefonun sahibinin yüzünün yarısını bile görmesi yeterli oluyor. Bu durumu Bkav araştırmacıları, “Kendi iPhone X cihazınızla deneyebilirsiniz, yüzünüzün yarısını kapladığınızda dahi telefon sizi tanıyacaktır. Bu, tanıma mekanizmasının sandığınız kadar sıkı olmadığını, Apple’ın Face ID’nin yapay zekasına çok fazla güveniyor olduğunu gösteriyor. Maskeyi oluşturmak için yarım yüze ihtiyacımız var. Bizim düşündüğümüzden daha basitti.” şeklinde açıkladı ve maskenin popüler bir üç boyutlu yazıcı kullanılarak basıldığını, burun kısmının el emeğiyle eklendiğini, diğer kısımlar için 2 boyutlu fotoğraflar kullanıldığını ve bunun bir el üretimi olduğunu ekledi.Maske toplamda 150$ gibi bir maliyetle oluşturuldu fakat güvenlik şirketinin kaç deneme sonucunda başarıya ulaştığı bilinmiyor. Herhangi birinin yüzünün modellenmesi ve maske haline getirilmesi uzun bir süreç olduğu için, iPhone X kullanıcılarının kaygılanmasına gerek yok :)",
            "content_html": "<p>Apple Iphone serisinin en son duyurulan modeli iPhone X ile birlikte gelen yeni güvenlik altyapısı Face ID, güvenlik araştırmacıları tarafından kırıldı. Toplamda 150$’dan daha az bir maliyetle geliştirilen maske ile cihazın kilidi açıldı.</p><p>Apple Face ID teknolojisini ultra güvenli olarak duyurmuştu. Fakat siber güvenlik firması Bkav araştırmacıları; cihaz sahibinin yüzünü 3 boyutlu yazıcı ile basılan maske, 2 boyutlu fotoğraf ve biraz makyaj ile silikondan tekrar oluşturdu. Oluşturulan maske ile iPhone X Face ID teknolojisi cihazın gerçek sahibiymiş gibi kandırıldı ve cihaza erişim sağlanmış oldu.</p><p><img src=\"/assets/images/post/iphone-face-id-mask.png\" alt=\"Apple iPhone X Face ID Mask\" title=\"Apple iPhone X Face ID Mask\" /></p><p>Dünya’da bir çok kullanıcı ve araştırmacı tarafından yapılan maskeler kullanılarak ve farklı yöntemlerle Face ID aşılmaya çalışıldı fakat hiçbiri başarılı olamadı. Bunun nedeni Face ID’nin yapay zekasının nasıl çalıştığının tam olarak anlaşılamamış olmasıydı.</p><p>iPhone X ekran kilidinin açılması için, telefonun sahibinin yüzünün yarısını bile görmesi yeterli oluyor. Bu durumu Bkav araştırmacıları, “Kendi iPhone X cihazınızla deneyebilirsiniz, yüzünüzün yarısını kapladığınızda dahi telefon sizi tanıyacaktır. Bu, tanıma mekanizmasının sandığınız kadar sıkı olmadığını, Apple’ın Face ID’nin yapay zekasına çok fazla güveniyor olduğunu gösteriyor. Maskeyi oluşturmak için yarım yüze ihtiyacımız var. Bizim düşündüğümüzden daha basitti.” şeklinde açıkladı ve maskenin popüler bir üç boyutlu yazıcı kullanılarak basıldığını, burun kısmının el emeğiyle eklendiğini, diğer kısımlar için 2 boyutlu fotoğraflar kullanıldığını ve bunun bir el üretimi olduğunu ekledi.</p><p>Maske toplamda 150$ gibi bir maliyetle oluşturuldu fakat güvenlik şirketinin kaç deneme sonucunda başarıya ulaştığı bilinmiyor. Herhangi birinin yüzünün modellenmesi ve maske haline getirilmesi uzun bir süreç olduğu için, iPhone X kullanıcılarının kaygılanmasına gerek yok :)</p>",
            "url": "https://hakan.io/apple-iphone-x-face-id-maske-kullanilarak-asildi/",
            
            
            
            "tags": ["apple","face id"],
            
            "date_published": "2017-11-16T03:00:00+03:00",
            "date_modified": "2017-11-16T03:00:00+03:00",
            
                "author": "Hakan"
            
        },
    
        {
            "id": "https://hakan.io/python-scrapy-kurulumu-ve-kullanimi/",
            "title": "Python Scrapy Kurulumu Ve Kullanımı",
            "summary": null,
            "content_text": "Scrapy Python ile yazılmış, html ve xml gibi yapısal içeriklerden verilerin ayıklanmasını sağlayan açık kaynak bir frameworktür. Özellikle web siteleri üzerinde yeterince hızlı bir şekilde scraping ve crawling yapabilmektedir.pip kurulu sistemler üzerindepip install scrapykomutu ile kurulumu yapılabilir. Kurulum gerçekleştirildikten sonra terminal üzerinden proje dizininde,scrapy startproject tutorialkomutuyla yeni bir scrapy projesi oluşturulur. Bir scrapy projesi oluşturulduğunda şu şekilde bir dosya/dizin yapısı oluşmuş olacaktır.tutorial/    scrapy.cfg            # deploy configuration file    tutorial/             # project's Python module, you'll import your code from here        __init__.py        items.py          # project items definition file        pipelines.py      # project pipelines file        settings.py       # project settings file        spiders/          # a directory where you'll later put your spiders            __init__.pyÖrnek bir spiderimport scrapyclass QuotesSpider(scrapy.Spider):    name = \"quotes\"    start_urls = [        'http://quotes.toscrape.com/page/1/',        'http://quotes.toscrape.com/page/2/',    ]    def parse(self, response):        for quote in response.css('div.quote'):            yield {                'text': quote.css('span.text::text').extract_first(),                'author': quote.css('small.author::text').extract_first(),                'tags': quote.css('div.tags a.tag::text').extract(),            }Scrapy örümcekleri ile bir veya birden fazla adres üzerinde tarama ve veri çıkarma işlemi yapılabilmektedir. Scrapy seçicileri ile istenen alanlar seçilip filtrelenebilmektedir. Scrapy seçicilerinde xpath scrapy tarafından desteklenmektedir.Crawl etmek içinscrapy crawl quotesElde edilen çıktıyı json formatında bir dosyaya yazmak içinscrapy crawl quotes -o qutoes.jsonkomutu kullanılabilir.",
            "content_html": "<p>Scrapy Python ile yazılmış, html ve xml gibi yapısal içeriklerden verilerin ayıklanmasını sağlayan açık kaynak bir frameworktür. Özellikle web siteleri üzerinde yeterince hızlı bir şekilde scraping ve crawling yapabilmektedir.</p><p>pip kurulu sistemler üzerinde</p><figure class=\"highlight\"><pre><code class=\"language-bash\" data-lang=\"bash\">pip <span class=\"nb\">install </span>scrapy</code></pre></figure><p>komutu ile kurulumu yapılabilir. Kurulum gerçekleştirildikten sonra terminal üzerinden proje dizininde,</p><figure class=\"highlight\"><pre><code class=\"language-bash\" data-lang=\"bash\">scrapy startproject tutorial</code></pre></figure><p>komutuyla yeni bir scrapy projesi oluşturulur. Bir scrapy projesi oluşturulduğunda şu şekilde bir dosya/dizin yapısı oluşmuş olacaktır.</p><figure class=\"highlight\"><pre><code class=\"language-bash\" data-lang=\"bash\">tutorial/    scrapy.cfg            <span class=\"c\"># deploy configuration file</span>    tutorial/             <span class=\"c\"># project's Python module, you'll import your code from here</span>        __init__.py        items.py          <span class=\"c\"># project items definition file</span>        pipelines.py      <span class=\"c\"># project pipelines file</span>        settings.py       <span class=\"c\"># project settings file</span>        spiders/          <span class=\"c\"># a directory where you'll later put your spiders</span>            __init__.py</code></pre></figure><p>Örnek bir spider</p><figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"kn\">import</span> <span class=\"nn\">scrapy</span><span class=\"k\">class</span> <span class=\"nc\">QuotesSpider</span><span class=\"p\">(</span><span class=\"n\">scrapy</span><span class=\"p\">.</span><span class=\"n\">Spider</span><span class=\"p\">):</span>    <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s\">\"quotes\"</span>    <span class=\"n\">start_urls</span> <span class=\"o\">=</span> <span class=\"p\">[</span>        <span class=\"s\">'http://quotes.toscrape.com/page/1/'</span><span class=\"p\">,</span>        <span class=\"s\">'http://quotes.toscrape.com/page/2/'</span><span class=\"p\">,</span>    <span class=\"p\">]</span>    <span class=\"k\">def</span> <span class=\"nf\">parse</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">response</span><span class=\"p\">):</span>        <span class=\"k\">for</span> <span class=\"n\">quote</span> <span class=\"ow\">in</span> <span class=\"n\">response</span><span class=\"p\">.</span><span class=\"n\">css</span><span class=\"p\">(</span><span class=\"s\">'div.quote'</span><span class=\"p\">):</span>            <span class=\"k\">yield</span> <span class=\"p\">{</span>                <span class=\"s\">'text'</span><span class=\"p\">:</span> <span class=\"n\">quote</span><span class=\"p\">.</span><span class=\"n\">css</span><span class=\"p\">(</span><span class=\"s\">'span.text::text'</span><span class=\"p\">).</span><span class=\"n\">extract_first</span><span class=\"p\">(),</span>                <span class=\"s\">'author'</span><span class=\"p\">:</span> <span class=\"n\">quote</span><span class=\"p\">.</span><span class=\"n\">css</span><span class=\"p\">(</span><span class=\"s\">'small.author::text'</span><span class=\"p\">).</span><span class=\"n\">extract_first</span><span class=\"p\">(),</span>                <span class=\"s\">'tags'</span><span class=\"p\">:</span> <span class=\"n\">quote</span><span class=\"p\">.</span><span class=\"n\">css</span><span class=\"p\">(</span><span class=\"s\">'div.tags a.tag::text'</span><span class=\"p\">).</span><span class=\"n\">extract</span><span class=\"p\">(),</span>            <span class=\"p\">}</span></code></pre></figure><p>Scrapy örümcekleri ile bir veya birden fazla adres üzerinde tarama ve veri çıkarma işlemi yapılabilmektedir. Scrapy seçicileri ile istenen alanlar seçilip filtrelenebilmektedir. Scrapy seçicilerinde xpath scrapy tarafından desteklenmektedir.</p><p>Crawl etmek için</p><figure class=\"highlight\"><pre><code class=\"language-bash\" data-lang=\"bash\">scrapy crawl quotes</code></pre></figure><p>Elde edilen çıktıyı json formatında bir dosyaya yazmak için</p><figure class=\"highlight\"><pre><code class=\"language-bash\" data-lang=\"bash\">scrapy crawl quotes <span class=\"nt\">-o</span> qutoes.json</code></pre></figure><p>komutu kullanılabilir.</p>",
            "url": "https://hakan.io/python-scrapy-kurulumu-ve-kullanimi/",
            
            
            
            "tags": ["python","scrapy","kurulum","kullanım"],
            
            "date_published": "2017-10-07T03:15:12+03:00",
            "date_modified": "2017-10-07T03:15:12+03:00",
            
                "author": "Hakan"
            
        },
    
        {
            "id": "https://hakan.io/2013-yilinda-1-degil-3-milyar-yahoo-kullanici-verisi-calindi/",
            "title": "2013 Yılında 1 Değil 3 Milyar Yahoo Kullanıcı Bilgisi Çalındı",
            "summary": null,
            "content_text": "Yahoo’nun geçen yıl Aralık ayında açıklanan, 2013 yılındaki veri ihlali sonucunda sızan 1 milyar hesap miktarı yeni açıklamayla birlikte 3 milyara yükseldi.Bu yıl Verizon tarafından satın alınan internet devi Yahoo, 2013 yılında uğradığı saldırılar sonucunda yaklaşık 1 milyar kullanıcısının isim, e-posta, doğum tarihi, telefon numarası ve parolalarının sızdığını açıklamıştı. Fakat geçen süre zarfında yapılan yeni çalışmalarla birlikte Yahoo’nun 1 milyar kullanıcı olarak açıkladığı rakam 3 milyara yükseldi.Tarihteki en büyük veri sızıntılarından biriyle karşı karşıya kalan Yahoo, kullanıcılarının kredi kartı bilgilerinin sızmadığını açıklamıştı.Yahoo Verizon tarafından satın alındıktan sonra, şirket yeni istihbaratlar elde etti ve uzmanların yardımıyla yapılan soruşturmalar neticesinde tüm Yahoo kullanıcılarının Ağustos 2013 tarihinde yaşanan veri sızıntısından etkinlendiğini düşündüklerini açıkladı.Yahoo’nun devasa boyuttaki bu veri sızıntısı sonucunda Yahoo hesabınızda kullandığınız parola ve güvenlik sorularınızı başka servislerde kullanıyorsanız parolalarını güncellemeniz yararınıza olacaktır.",
            "content_html": "<p>Yahoo’nun geçen yıl Aralık ayında açıklanan, 2013 yılındaki veri ihlali sonucunda sızan 1 milyar hesap miktarı yeni açıklamayla birlikte 3 milyara yükseldi.</p><p>Bu yıl Verizon tarafından satın alınan internet devi Yahoo, 2013 yılında uğradığı saldırılar sonucunda yaklaşık 1 milyar kullanıcısının isim, e-posta, doğum tarihi, telefon numarası ve parolalarının sızdığını açıklamıştı. Fakat geçen süre zarfında yapılan yeni çalışmalarla birlikte Yahoo’nun 1 milyar kullanıcı olarak açıkladığı rakam 3 milyara yükseldi.</p><p>Tarihteki en büyük veri sızıntılarından biriyle karşı karşıya kalan Yahoo, kullanıcılarının kredi kartı bilgilerinin sızmadığını açıklamıştı.</p><p>Yahoo Verizon tarafından satın alındıktan sonra, şirket yeni istihbaratlar elde etti ve uzmanların yardımıyla yapılan soruşturmalar neticesinde tüm Yahoo kullanıcılarının Ağustos 2013 tarihinde yaşanan veri sızıntısından etkinlendiğini düşündüklerini açıkladı.</p><p>Yahoo’nun devasa boyuttaki bu veri sızıntısı sonucunda Yahoo hesabınızda kullandığınız parola ve güvenlik sorularınızı başka servislerde kullanıyorsanız parolalarını güncellemeniz yararınıza olacaktır.</p>",
            "url": "https://hakan.io/2013-yilinda-1-degil-3-milyar-yahoo-kullanici-verisi-calindi/",
            
            
            
            "tags": ["yahoo","veri ihlali"],
            
            "date_published": "2017-10-05T03:00:00+03:00",
            "date_modified": "2017-10-05T03:00:00+03:00",
            
                "author": "Hakan"
            
        },
    
        {
            "id": "https://hakan.io/ucretsiz-vpn-servisleri-gercekten-ucretsiz-mi/",
            "title": "Ücretsiz VPN servisleri gerçekten ücretsiz mi?",
            "summary": null,
            "content_text": "Erişim engellemelerinin ardı ardına geldiği, Wikipedia maddesi okuyabilmek için VPN kullanılan bir ortamda asıl tehlike ne?VPN yaygın olarak, erişim engellemelerini aşabilmek ve anonim kalabilmek adına kullanılıyor. Türkiye oransal olarak Dünya’nın en fazla VPN kullanan ülkesi. Ocak 2017 raporuna göre Türkiye’de VPN kullanım oranı %50 seviyelerinde.Peki bu oran ne anlama geliyor? Global Web Index istatistiklerine göre; Türkiye’de 16-64 yaş aralığındaki internet kullanıcıların yaklaşık %50’si VPN veya proxy sunucusu kullanıyor. Kaba bir hesapla Türkiye internet trafiğinin %50’si -%50 net bir oran olmasa bile önemli bir kısmı- VPN sunucuları üzerinden geçiyor.İnternet kullanıcıları, sansürü aşabilmek için VPN sunucuları üzerinden bağlantı sağlarken ezici bir çoğunluğu ücretsiz servisleri kullanıyor. Öyle ki, yakın bir tarihte popüler VPN servislerinden birkaçı Türkiye’de engellendikten sonra, tüm VPN trafiğinin engellendiği algısı oluşmuştu. Yine Türkiye kullanıcılarının çoğunu ücretsiz kullanıcıların oluşturduğu VPN hizmeti sunan bu şirketler, engelin ardından tekrar hizmet verebilmek için bir hayli çaba sarfetmişlerdi.Ücretsiz hizmet sağlayıcılar, ücretsiz hizmet verebilmek için neden bu kadar çabalar?“If you are not paying for the product, you are the product.”Ücretsiz vpn servisleri, kullanıcılarının internet trafiğini kayıt altına alabilir ve kullanıcılarının bağlantı hareketlerinden elde edebilecekleri bilgilerle fazlasıyla işe yarayacak veri setleri elde edebilir. Bu veri setleri, bölgesel istatistiklerden reklam hedeflemelerine kadar çok fazla sayıda alanda kullanılabilir ve üçüncü parti şirketlere satılabilir. Ayrıca, anonim kalmak isteyen kullanıcısının, tam tersi bir şekilde tüm kimliğinin açığa çıkmasına doğrudan veya dolaylı yoldan sebep olabilir. Tabi ki ücretsiz hizmet sağlayıcıların çok daha fazla parametreye tabi amaç ve/veya beklentileri olabilir. Bu sebeple kullanıcı ürüne veya hizmete ödeme yapmadan kullanmak isterken ürünün kendisi olmadığından emin olmalıdır.Elbette, tüm ücretsiz servisler/ürünler, servisin veya ürünün kendisinden bir kar amacı gütmek zorunda değildir. Pek çok farklı sivil hareket, tamamiyle ücretsiz, gönüllülük esasına göre işleyen, güvenli hizmetler sunabilmektedir.",
            "content_html": "<p>Erişim engellemelerinin ardı ardına geldiği, Wikipedia maddesi okuyabilmek için VPN kullanılan bir ortamda asıl tehlike ne?</p><p>VPN yaygın olarak, erişim engellemelerini aşabilmek ve anonim kalabilmek adına kullanılıyor. Türkiye oransal olarak Dünya’nın en fazla VPN kullanan ülkesi. Ocak 2017 raporuna göre Türkiye’de VPN kullanım oranı %50 seviyelerinde.</p><p>Peki bu oran ne anlama geliyor? Global Web Index istatistiklerine göre; Türkiye’de 16-64 yaş aralığındaki internet kullanıcıların yaklaşık %50’si VPN veya proxy sunucusu kullanıyor. Kaba bir hesapla Türkiye internet trafiğinin %50’si -%50 net bir oran olmasa bile önemli bir kısmı- VPN sunucuları üzerinden geçiyor.</p><p>İnternet kullanıcıları, sansürü aşabilmek için VPN sunucuları üzerinden bağlantı sağlarken ezici bir çoğunluğu ücretsiz servisleri kullanıyor. Öyle ki, yakın bir tarihte popüler VPN servislerinden birkaçı Türkiye’de engellendikten sonra, tüm VPN trafiğinin engellendiği algısı oluşmuştu. Yine Türkiye kullanıcılarının çoğunu ücretsiz kullanıcıların oluşturduğu VPN hizmeti sunan bu şirketler, engelin ardından tekrar hizmet verebilmek için bir hayli çaba sarfetmişlerdi.</p><p>Ücretsiz hizmet sağlayıcılar, ücretsiz hizmet verebilmek için neden bu kadar çabalar?</p><p>“If you are not paying for the product, you are the product.”</p><p>Ücretsiz vpn servisleri, kullanıcılarının internet trafiğini kayıt altına alabilir ve kullanıcılarının bağlantı hareketlerinden elde edebilecekleri bilgilerle fazlasıyla işe yarayacak veri setleri elde edebilir. Bu veri setleri, bölgesel istatistiklerden reklam hedeflemelerine kadar çok fazla sayıda alanda kullanılabilir ve üçüncü parti şirketlere satılabilir. Ayrıca, anonim kalmak isteyen kullanıcısının, tam tersi bir şekilde tüm kimliğinin açığa çıkmasına doğrudan veya dolaylı yoldan sebep olabilir. Tabi ki ücretsiz hizmet sağlayıcıların çok daha fazla parametreye tabi amaç ve/veya beklentileri olabilir. Bu sebeple kullanıcı ürüne veya hizmete ödeme yapmadan kullanmak isterken ürünün kendisi olmadığından emin olmalıdır.</p><p>Elbette, tüm ücretsiz servisler/ürünler, servisin veya ürünün kendisinden bir kar amacı gütmek zorunda değildir. Pek çok farklı sivil hareket, tamamiyle ücretsiz, gönüllülük esasına göre işleyen, güvenli hizmetler sunabilmektedir.</p>",
            "url": "https://hakan.io/ucretsiz-vpn-servisleri-gercekten-ucretsiz-mi/",
            
            
            
            "tags": ["Ücretsiz","Vpn","Servis"],
            
            "date_published": "2017-09-12T03:15:12+03:00",
            "date_modified": "2017-09-12T03:15:12+03:00",
            
                "author": "Hakan"
            
        },
    
        {
            "id": "https://hakan.io/methbot-tarihin-en-buyuk-reklam-dolandiriciligi/",
            "title": "Methbot: Tarihin En Büyük Reklam Dolandırıcılığı",
            "summary": null,
            "content_text": "Dijital reklam pazarı birilerinin iştahını fena halde kabartmış görünüyor. Rusya kökenli olduğu düşünülen dünya’nın en büyük reklam dolandırıcılığı şebekesinin yaptığı vurgun dudak uçuklatacak seviyelerde. Tarihin en büyük dijital reklam dolandırıcılığı, güvenlik şirketi Whiteops tarafından aydınlatıldı. Whiteops’un yayınladığı rapor ile bu haksız kazancın önüne geçilmesine yönelik bilgilendirme ve önlem çağrısı yapıldı.ABD ve Hollanda’daki veri merkezlerinde faaliyet gösteren binlerce sunucu ile kurulmuş bot çiftliğini yöneten Rus hacker grubu, video reklam ekosistemini hedefleyerek sahte tıklamalar ve izleme sayılarıyla günde ortalama 3-5 milyon dolar arasında hileli gelir elde ediyor. Methbot botnetini yöneten grubun yalnızca sunucularına aylık ortalama 200bin dolar harcadığı tahmin ediliyor.Video reklamların izlenilmesine yönelik yapılan reklam modellemelerinde, methbot botneti sahte izlenme sayıları yaratarak haksız kazanç elde ediyor.  Methbot toplamda 800 ila 1200 arasında dedicated sunucuya sahip  Toplamda 572.000 IP adresine sahip  Dağıtık bir sistem kullanıyor  Bot korumalarına karşı tarayıcı kimliğine bürünebiliyor  Sahte tarayıcı bilgileri, ekran çözünürlüğü gibi karakteristik ekran bilgileri, eklenti listesi oluşturarak tarayıcı gibi davranabiliyor.Bugüne kadar keşfedilen botnetlerin elde ettiği haksız kazançlar içerisinde Methbot günlük ortalama 3 milyon dolarla listenin başında yer alıyor.Reklam ortaklığında büyük bir pay sahibi olan video reklamların ölçümlenmesi, methbot’un ortaya çıkarılmasıyla birlikte yeniden gözden geçirilmeli ve gerekli önlemler alınmalıdır.",
            "content_html": "<p><img src=\"/assets/images/post/methbot.png\" alt=\"Methbot\" title=\"Methbot\" /></p><p>Dijital reklam pazarı birilerinin iştahını fena halde kabartmış görünüyor. Rusya kökenli olduğu düşünülen dünya’nın en büyük reklam dolandırıcılığı şebekesinin yaptığı vurgun dudak uçuklatacak seviyelerde. Tarihin en büyük dijital reklam dolandırıcılığı, güvenlik şirketi Whiteops tarafından aydınlatıldı. Whiteops’un yayınladığı rapor ile bu haksız kazancın önüne geçilmesine yönelik bilgilendirme ve önlem çağrısı yapıldı.</p><p>ABD ve Hollanda’daki veri merkezlerinde faaliyet gösteren binlerce sunucu ile kurulmuş bot çiftliğini yöneten Rus hacker grubu, video reklam ekosistemini hedefleyerek sahte tıklamalar ve izleme sayılarıyla günde ortalama 3-5 milyon dolar arasında hileli gelir elde ediyor. Methbot botnetini yöneten grubun yalnızca sunucularına aylık ortalama 200bin dolar harcadığı tahmin ediliyor.</p><p>Video reklamların izlenilmesine yönelik yapılan reklam modellemelerinde, methbot botneti sahte izlenme sayıları yaratarak haksız kazanç elde ediyor.</p><ul>  <li>Methbot toplamda 800 ila 1200 arasında dedicated sunucuya sahip</li>  <li>Toplamda 572.000 IP adresine sahip</li>  <li>Dağıtık bir sistem kullanıyor</li>  <li>Bot korumalarına karşı tarayıcı kimliğine bürünebiliyor</li>  <li>Sahte tarayıcı bilgileri, ekran çözünürlüğü gibi karakteristik ekran bilgileri, eklenti listesi oluşturarak tarayıcı gibi davranabiliyor.</li></ul><p>Bugüne kadar keşfedilen botnetlerin elde ettiği haksız kazançlar içerisinde Methbot günlük ortalama 3 milyon dolarla listenin başında yer alıyor.</p><p>Reklam ortaklığında büyük bir pay sahibi olan video reklamların ölçümlenmesi, methbot’un ortaya çıkarılmasıyla birlikte yeniden gözden geçirilmeli ve gerekli önlemler alınmalıdır.</p>",
            "url": "https://hakan.io/methbot-tarihin-en-buyuk-reklam-dolandiriciligi/",
            "image": "assets/images/post/methbot.png",
            
            
            
            
            "date_published": "2016-12-22T16:00:00+03:00",
            "date_modified": "2016-12-22T16:00:00+03:00",
            
                "author": "Hakan"
            
        },
    
        {
            "id": "https://hakan.io/tor-turkiyede-engellendi/",
            "title": "TOR Türkiye'de Engellendi",
            "summary": null,
            "content_text": "Daha çok internette anonim olmak isteyen kullanıcıların kullandığı, TOR (The Onion Route(r) Project) Türkiye’de engellendi. Verinin uçtan uça aktarımını, kendi kullanıcılarının oluşturduğu ağ üzerinde, her geçtiği noktada paketleri şifreleyerek sağlayan TOR projesine erişimin engellendiğini ilk olarak Turkey Blocks duyurdu. Geçtiğimiz ay VPN Servis Engeli ile popüler vpn servislerine erişim engellenmişti.Ancak TOR ağına dahil olan kullanıcıların bu durumu aşması basit konfigürasyonlarla mümkün. TOR projesinin twitter hesabında hazırlanan bir gif ile, engelin TOR Browser kullanan kullanıcılar tarafından nasıl aşılacağı görsel olarak anlatılıyor. TOR projesinin sansüre uğradığı ilk ülke Türkiye değil. Aralarında Çin ve Kazakistan’ın bulunduğu bazı ülkeler TOR ağına daha önce sansür uygulamış ancak TOR projesinin mimarisi gereği tam anlamıyla bir engelleme sağlayamamıştı.",
            "content_html": "<p><img src=\"/assets/images/post/tor.jpg\" alt=\"TOR\" title=\"TOR\" /></p><p>Daha çok internette anonim olmak isteyen kullanıcıların kullandığı, TOR (The Onion Route(r) Project) Türkiye’de engellendi. Verinin uçtan uça aktarımını, kendi kullanıcılarının oluşturduğu ağ üzerinde, her geçtiği noktada paketleri şifreleyerek sağlayan TOR projesine erişimin engellendiğini ilk olarak Turkey Blocks duyurdu. Geçtiğimiz ay VPN Servis Engeli ile popüler vpn servislerine erişim engellenmişti.</p><p>Ancak TOR ağına dahil olan kullanıcıların bu durumu aşması basit konfigürasyonlarla mümkün. TOR projesinin twitter hesabında hazırlanan bir gif ile, engelin TOR Browser kullanan kullanıcılar tarafından nasıl aşılacağı görsel olarak anlatılıyor. TOR projesinin sansüre uğradığı ilk ülke Türkiye değil. Aralarında Çin ve Kazakistan’ın bulunduğu bazı ülkeler TOR ağına daha önce sansür uygulamış ancak TOR projesinin mimarisi gereği tam anlamıyla bir engelleme sağlayamamıştı.</p>",
            "url": "https://hakan.io/tor-turkiyede-engellendi/",
            
            
            
            
            
            "date_published": "2016-12-20T12:30:00+03:00",
            "date_modified": "2016-12-20T12:30:00+03:00",
            
                "author": "Hakan"
            
        },
    
        {
            "id": "https://hakan.io/guvenli-sekilde-dosya-silme/",
            "title": "Güvenli Şekilde Dosya Silme",
            "summary": null,
            "content_text": "Bilgisayar sistemlerinde, dosya sistemi üzerinden kullanıcı tarafından silinen bir dosyanın çoğu zaman geri getirilmesi mümkündür. Sistemler çoğu zaman performansı iyileştirmek adına, dosyaları silmek yerine sadece işletim sistemi tarafından görüntülenmesini durdurur. Esasında kullanıcı tarafından verilen, windows kullanıcıları için delete,shift+delete linux ve osx kullanıcıları için rm ve masaüstü yöneticisinden yapılan sil komutu ve tüm çöp/geri dönüşüm kutusu işlemleri disk üzerinde gerçek bir silme işlemi gerçekleştirmez.Bilgisayarın el değiştirmesi, geri dönüşüme kazandırılması, ticari veya bireysel kaygılar güvenli dosya silmenizi gerektirecek başlıca sebepler.Tam ve güvenli bir dosya silme işlemi genellikle ilgili dosyanın disk üzerindeki alanına rastgele veri yazılması-silinmesi işleminin tekrarlanması sonucunda gerçekleşir. Manyetik diskler üzerindeki dosya izleri bu sayede silinen dosyayla ilgili bir veri içermeyecek hale getirilir.Linux KullanıcılarıLinux kullanıcıları, çoğu dağıtımda önyüklü olarak gelen shred aracı ile tam ve güvenli bir silme işlemi gerçekleştirebilir. Shred komut satırı üzerinden çalışan bir araçtır.shred -uzfv -n 20 ornekdosya.txtYukarıdaki komut ile ornekdosya.txt dosyasının disk üzerindeki alanına 20 kez rastgele veri yazılır ve 21.kez tüm dosya alanı 0 ile doldurulur. Dosya ismi defalarca değiştirilir ve sonucunda güvenli bir şekilde dosya silme işlemi gerçekleşmiş olur.OsX KullanıcılarıOsX kullanıcıları ise işletim sistemi üzerinde gelen, komut satırı üzerinden kullanılan srm aracı ile güvenli silme işlemi gerçekleştirebilirler.srm ornekdosya.txtsrm -r ornekdizinWindows KullanıcılarıWindows kullanıcıları benzer işlemleri gerçekleştirerek güvenli dosya silme işlemi için https://eraser.heidi.ie/ adresindeki aracı kullanabilir.Son olarak Bilgisayar sistemlerinde 100% güvenlidir ifadesi her zaman için doğru olmayabilir. Anlatılan silme işlemleri sonucunda, özellikle manyetik disklerde ilgili dosyayla ilgili bazı küçük izlere ulaşmak imkansıza yakın olmakla birlikte mümkündür.",
            "content_html": "<p>Bilgisayar sistemlerinde, dosya sistemi üzerinden kullanıcı tarafından silinen bir dosyanın çoğu zaman geri getirilmesi mümkündür. Sistemler çoğu zaman performansı iyileştirmek adına, dosyaları silmek yerine sadece işletim sistemi tarafından görüntülenmesini durdurur. Esasında kullanıcı tarafından verilen, windows kullanıcıları için delete,shift+delete linux ve osx kullanıcıları için rm ve masaüstü yöneticisinden yapılan sil komutu ve tüm çöp/geri dönüşüm kutusu işlemleri disk üzerinde gerçek bir silme işlemi gerçekleştirmez.</p><p>Bilgisayarın el değiştirmesi, geri dönüşüme kazandırılması, ticari veya bireysel kaygılar güvenli dosya silmenizi gerektirecek başlıca sebepler.</p><p>Tam ve güvenli bir dosya silme işlemi genellikle ilgili dosyanın disk üzerindeki alanına rastgele veri yazılması-silinmesi işleminin tekrarlanması sonucunda gerçekleşir. Manyetik diskler üzerindeki dosya izleri bu sayede silinen dosyayla ilgili bir veri içermeyecek hale getirilir.</p><p><strong>Linux Kullanıcıları</strong></p><p>Linux kullanıcıları, çoğu dağıtımda önyüklü olarak gelen shred aracı ile tam ve güvenli bir silme işlemi gerçekleştirebilir. Shred komut satırı üzerinden çalışan bir araçtır.</p><figure class=\"highlight\"><pre><code class=\"language-c\" data-lang=\"c\"><span class=\"n\">shred</span> <span class=\"o\">-</span><span class=\"n\">uzfv</span> <span class=\"o\">-</span><span class=\"n\">n</span> <span class=\"mi\">20</span> <span class=\"n\">ornekdosya</span><span class=\"p\">.</span><span class=\"n\">txt</span></code></pre></figure><p>Yukarıdaki komut ile ornekdosya.txt dosyasının disk üzerindeki alanına 20 kez rastgele veri yazılır ve 21.kez tüm dosya alanı 0 ile doldurulur. Dosya ismi defalarca değiştirilir ve sonucunda güvenli bir şekilde dosya silme işlemi gerçekleşmiş olur.</p><p><img src=\"/assets/images/post/linux-shred-dosya-silme.png\" alt=\"Linux Shred\" title=\"Linux Shred\" /></p><p><strong>OsX Kullanıcıları</strong></p><p>OsX kullanıcıları ise işletim sistemi üzerinde gelen, komut satırı üzerinden kullanılan srm aracı ile güvenli silme işlemi gerçekleştirebilirler.</p><figure class=\"highlight\"><pre><code class=\"language-c\" data-lang=\"c\"><span class=\"n\">srm</span> <span class=\"n\">ornekdosya</span><span class=\"p\">.</span><span class=\"n\">txt</span><span class=\"n\">srm</span> <span class=\"o\">-</span><span class=\"n\">r</span> <span class=\"n\">ornekdizin</span></code></pre></figure><p><strong>Windows Kullanıcıları</strong></p><p>Windows kullanıcıları benzer işlemleri gerçekleştirerek güvenli dosya silme işlemi için https://eraser.heidi.ie/ adresindeki aracı kullanabilir.</p><p>Son olarak Bilgisayar sistemlerinde 100% güvenlidir ifadesi her zaman için doğru olmayabilir. Anlatılan silme işlemleri sonucunda, özellikle manyetik disklerde ilgili dosyayla ilgili bazı küçük izlere ulaşmak imkansıza yakın olmakla birlikte mümkündür.</p>",
            "url": "https://hakan.io/guvenli-sekilde-dosya-silme/",
            
            
            
            "tags": ["güvenli dosya silme","kalıcı dosya silme","shred","osx srm","eraser"],
            
            "date_published": "2016-11-30T03:00:00+03:00",
            "date_modified": "2016-11-30T03:00:00+03:00",
            
                "author": "Hakan"
            
        },
    
        {
            "id": "https://hakan.io/turkiyede-erisim-engellemelerinde-yeni-bir-boyut-vpn-servis-engeli/",
            "title": "Türkiye'de Erişim Engellemelerinde Yeni Bir Boyut: VPN Servis Engeli",
            "summary": null,
            "content_text": "Türkiye’de uzun yıllardır zaman zaman veya sürekli olarak uygulanan erişim engelleri, yeni bir boyut kazanıyor. İnternet kullanıcıları erişim engellerini aşmak için VPN hizmetlerine yönelmişti. Ancak 4 Kasım 2016 tarihi itibariyle Bilgi Teknolojileri Ve İletişim Kurumu (BTK) tarafından verilen kararla servis sağlayıcıları VPN servislerini engellemeye başladı.Türkiye’de uygulanan erişim engelleri, öncelikle servis sağlayacıların dns sunucuları vasıtasıyla gerçekleştirilmeye başlanmıştı. İnternet kullanıcılarının farklı dns sunucularını kullanmasıyla bu engelin aşılması bir hayli kolay olmuş ve kullanıcılar tarafından uygulanan ilk erişim aşma yöntemi olarak kullanılmaya başlanmıştı. Sonrasında gelen engelleme yöntemleri ise, ip adres ve/veya bloklarının engellenmesi şeklinde gerçekleşmişti.Tüm bu engellerin aşılması için internet kullanıcıları son zamanlarda vpn servislerine yöneldi. Teknik ve teknik olmayan son kullanıcılar için vpn servisleri kullanım alışkanlığı kazanmış durumda.VPN Servisleri nasıl engelleniyor?VPN yani Virtual Private Network (Sanal Özel Ağ), servislerinin engellenmesi temelde iki yönteme dayanıyor. VPN servisleri yaygın olarak PPTP ve L2TP protokolleri üzerinde çalışıyor. Engel bu noktada protokollerin yaygın olarak kullandığı portların engellenmesi veya popüler vpn servislerinin ip adreslerinin engellenmesi şeklinde gerçekleştiriliyor.Türkiye’de yaygın olarak kullanılan vpn servislerinden Zenmate, Hotspot Shield, Private Internet Access, Tunnelbear ve IPVanish kullanıcılarının servis erişim sorunları başlamış durumda.Şimdilik kendi vpn sunucusunu ve yapılandırmasını kullanan kullanıcıların engellemeden etkilenmediğini belirtmekte fayda var.VPN Servis engelini uygulayan devletlerDünya’da vpn erişim engeli uygulayan devlet olarak bilinen İran ve Çin var. Çin internet kullanıcıları 2011 yılında vpn servislerine uygulanan erişim engellerini raporlamaya başladı. 2012 yılında ise bazı vpn servisleri Çin’in erişim engelini aşmayı başardıklarını raporladılar.İran hükümeti ise 2013 yılında VPN servislerinin engellenmesiyle ilgili çalışma başlatmıştı.Ne yapılmalı?VPN erişim engelinin, daha önce doğrulanmış yöntemlerle gerçekleştirilmiş olması durumunda aşılması mümkün değil. Yaygın olarak kullanılan vpn servis kullanıcılarının vpn sunucu yapılandırmalarına erişim yetkisi olmadığı için yapabilecekleri pek bir şey yok.Ancak kendi özel vpn sunucusunu yapılandırmış kullanıcılar şu an bir engellemeyle karşılaşmadı ve kendi sunucu ve yapılandırmasını kullanan tüm kullanıcıların tespit edilmesi ve engellenmesi teknik olarak mümkün olsa da pratikte pek mümkün değil.",
            "content_html": "<p>Türkiye’de uzun yıllardır zaman zaman veya sürekli olarak uygulanan erişim engelleri, yeni bir boyut kazanıyor. İnternet kullanıcıları erişim engellerini aşmak için VPN hizmetlerine yönelmişti. Ancak 4 Kasım 2016 tarihi itibariyle Bilgi Teknolojileri Ve İletişim Kurumu (BTK) tarafından verilen kararla servis sağlayıcıları VPN servislerini engellemeye başladı.</p><p>Türkiye’de uygulanan erişim engelleri, öncelikle servis sağlayacıların dns sunucuları vasıtasıyla gerçekleştirilmeye başlanmıştı. İnternet kullanıcılarının farklı dns sunucularını kullanmasıyla bu engelin aşılması bir hayli kolay olmuş ve kullanıcılar tarafından uygulanan ilk erişim aşma yöntemi olarak kullanılmaya başlanmıştı. Sonrasında gelen engelleme yöntemleri ise, ip adres ve/veya bloklarının engellenmesi şeklinde gerçekleşmişti.</p><p>Tüm bu engellerin aşılması için internet kullanıcıları son zamanlarda vpn servislerine yöneldi. Teknik ve teknik olmayan son kullanıcılar için vpn servisleri kullanım alışkanlığı kazanmış durumda.</p><p><strong>VPN Servisleri nasıl engelleniyor?</strong></p><p>VPN yani Virtual Private Network (Sanal Özel Ağ), servislerinin engellenmesi temelde iki yönteme dayanıyor. VPN servisleri yaygın olarak PPTP ve L2TP protokolleri üzerinde çalışıyor. Engel bu noktada protokollerin yaygın olarak kullandığı portların engellenmesi veya popüler vpn servislerinin ip adreslerinin engellenmesi şeklinde gerçekleştiriliyor.</p><p>Türkiye’de yaygın olarak kullanılan vpn servislerinden Zenmate, Hotspot Shield, Private Internet Access, Tunnelbear ve IPVanish kullanıcılarının servis erişim sorunları başlamış durumda.</p><p>Şimdilik kendi vpn sunucusunu ve yapılandırmasını kullanan kullanıcıların engellemeden etkilenmediğini belirtmekte fayda var.</p><p><strong>VPN Servis engelini uygulayan devletler</strong></p><p>Dünya’da vpn erişim engeli uygulayan devlet olarak bilinen İran ve Çin var. Çin internet kullanıcıları 2011 yılında vpn servislerine uygulanan erişim engellerini raporlamaya başladı. 2012 yılında ise bazı vpn servisleri Çin’in erişim engelini aşmayı başardıklarını raporladılar.</p><p>İran hükümeti ise 2013 yılında VPN servislerinin engellenmesiyle ilgili çalışma başlatmıştı.</p><p><strong>Ne yapılmalı?</strong></p><p>VPN erişim engelinin, daha önce doğrulanmış yöntemlerle gerçekleştirilmiş olması durumunda aşılması mümkün değil. Yaygın olarak kullanılan vpn servis kullanıcılarının vpn sunucu yapılandırmalarına erişim yetkisi olmadığı için yapabilecekleri pek bir şey yok.</p><p>Ancak kendi özel vpn sunucusunu yapılandırmış kullanıcılar şu an bir engellemeyle karşılaşmadı ve kendi sunucu ve yapılandırmasını kullanan tüm kullanıcıların tespit edilmesi ve engellenmesi teknik olarak mümkün olsa da pratikte pek mümkün değil.</p>",
            "url": "https://hakan.io/turkiyede-erisim-engellemelerinde-yeni-bir-boyut-vpn-servis-engeli/",
            
            
            
            "tags": ["vpn engellemeleri","sansür"],
            
            "date_published": "2016-11-04T03:00:00+03:00",
            "date_modified": "2016-11-04T03:00:00+03:00",
            
                "author": "Hakan"
            
        },
    
        {
            "id": "https://hakan.io/9-uluslararasi-bilgi-guvenligi-ve-kriptoloji-konferansi/",
            "title": "9. Uluslararası Bilgi Güvenliği ve Kriptoloji Konferansı",
            "summary": null,
            "content_text": "Bilgi güvenliği ve kriptoloji konferansı bu yıl 9. konferansını 25-26 Ekim 2016 tarihlerinde Ankara’da Orta Doğu Teknik Üniversitesi Kemal Kurdaş konferans salonunda gerçekleştiriyor. Düzenlendiği ilk yıldan beri; bilimsel ve endüstriyel çalışmaların paylaşıldığı, üniversite-kamu-endüstri işbirliğinin geliştirildiği, toplumun bilgi güvenliği farkındalığının artırıldığı, bilim insanları araştırmacılar ve sektör paydaşları arasında bilgi alışverişinin sağlandığı en önemli etkinlik olarak kabul edilmekte. ISC Turkey 2016 konferansı, Avrupa Ağ ve Bilgi Güvenliği Ajansı tarafından desteklenmekte ve Avrupa Siber Güvenlik Ayı etkinlikleri arasında yer almakta.Düzenlenmesinde, BTK, Bilgi Güvenliği Derneği, Gazi Üniversitesi, ODTÜ, Ulaştırma Denizcilik ve Haberleşme Bakanlığı ve İTÜ’nün yer aldığı ISC Turkey 2016 konferansının sponsorları arasında Aselsan, Havelsan, Netaş, Türk Telekom, Turkcell ve Vodafone yer alıyor.Bu yılki Konferansın ana teması “Siber Güvenlik ve Nesnelerin Interneti” olarak belirlenmiş. Konferansta Nesnelerin İnternetinde Siber Güvenlik, Nesnelerin İnterneti Regülasyonu, Nesnelerin İnternetinde Yerli Çözümler ve benzeri konular ele alınacak, konuşmacılar, akademik bildirilerin sunulacağı oturumlar ve eğitimler düzenlenecek.Konferans programı ve diğer bilgiler http://www.iscturkey.org adresinde.",
            "content_html": "<p><img src=\"/assets/images/post/9-bilgi-guvenligi-ve-kriptoloji-konferansi.jpg\" alt=\"Uluslararası Bilgi Güvenliği ve Kriptoloji Konferansı\" title=\"Uluslararası Bilgi Güvenliği ve Kriptoloji Konferansı\" /></p><p>Bilgi güvenliği ve kriptoloji konferansı bu yıl 9. konferansını 25-26 Ekim 2016 tarihlerinde Ankara’da Orta Doğu Teknik Üniversitesi Kemal Kurdaş konferans salonunda gerçekleştiriyor. Düzenlendiği ilk yıldan beri; bilimsel ve endüstriyel çalışmaların paylaşıldığı, üniversite-kamu-endüstri işbirliğinin geliştirildiği, toplumun bilgi güvenliği farkındalığının artırıldığı, bilim insanları araştırmacılar ve sektör paydaşları arasında bilgi alışverişinin sağlandığı en önemli etkinlik olarak kabul edilmekte. ISC Turkey 2016 konferansı, Avrupa Ağ ve Bilgi Güvenliği Ajansı tarafından desteklenmekte ve Avrupa Siber Güvenlik Ayı etkinlikleri arasında yer almakta.</p><p>Düzenlenmesinde, BTK, Bilgi Güvenliği Derneği, Gazi Üniversitesi, ODTÜ, Ulaştırma Denizcilik ve Haberleşme Bakanlığı ve İTÜ’nün yer aldığı ISC Turkey 2016 konferansının sponsorları arasında Aselsan, Havelsan, Netaş, Türk Telekom, Turkcell ve Vodafone yer alıyor.</p><p>Bu yılki Konferansın ana teması “Siber Güvenlik ve Nesnelerin Interneti” olarak belirlenmiş. Konferansta Nesnelerin İnternetinde Siber Güvenlik, Nesnelerin İnterneti Regülasyonu, Nesnelerin İnternetinde Yerli Çözümler ve benzeri konular ele alınacak, konuşmacılar, akademik bildirilerin sunulacağı oturumlar ve eğitimler düzenlenecek.</p><p>Konferans programı ve diğer bilgiler http://www.iscturkey.org adresinde.</p>",
            "url": "https://hakan.io/9-uluslararasi-bilgi-guvenligi-ve-kriptoloji-konferansi/",
            
            
            
            "tags": ["kriptoloji","bilgi güvenliği"],
            
            "date_published": "2016-10-23T03:00:00+03:00",
            "date_modified": "2016-10-23T03:00:00+03:00",
            
                "author": "Hakan"
            
        },
    
        {
            "id": "https://hakan.io/linkedin-parolalarinizi-kullanmaktan-vazgecin/",
            "title": "Linkedin Parolalarınızı Kullanmaktan Vazgeçin",
            "summary": null,
            "content_text": "Geçtiğimiz yıl Linkedin veritabanı hacklenmiş ve bu veritabanı uzunca bir süre torrent aracılığıyla elden ele dolaşmıştı. Uzunca bir süre bu olay gerek sosyal medya gerek teknoloji forumlarında konuşulmuş ve zamanla unutulmuştu. Ancak geçtiğimiz aylarda Microsoft’un Linkedin’i satın aldığını duyurması üzerine bu meşhur veritabanı tekrardan torrent paylaşımlarında boy göstermeye başladı. Bu ele geçirme ile birlikte yaklaşık olarak milyonlarca kullanıcının e-mail ve linkedin hesap bilgilerinin yanısıra parolaları da rahatlıkla erişilebilir bir formatta yine rahatlıkla erişilebilir noktalarda bulunuyor. Ortaya çıktığı dönemde Linkedin’e ait olduğu iddia edilen ve milyonlarca kullanıcının bilgisini içeren veritabanı dark web üzerinden 5 Bitcoin karşılığında satışa sunulmuştu.Ele geçirilen veritabanında Linkedin kullanıcılarının -en önemli olarak- e-mail ve parola bilgileri yer alıyordu. Parolalar şifrelenmemiş bir şekilde tutulmasa da, parolaların salt kullanılmadan ham bir şekilde SHA1 algoritması ile hashlenerek tutulduğu anlaşılınca parolaların %90’ı 72 saat içerisinde çözülmüştü.Not: Hash algoritmaları şifreleme algoritmaları değildir. Kabaca tek yönlü şifreleme işlemlerinde pratikte yaygın olarak kullanılmaktadır. Veritabanında kullanıcı parolasının hash değeri tutuluyorsa bir şifreleme-çözümleme yapılmaz, sadece kullanıcının giriş yaptığı parolasının hash değeri karşılaştırılır.Linkedin veritabanından elde edilen parolalar ile geçtiğimiz ay Mark Zuckerberg’in Twitter hesabıda aynı parolayı kullanması sonucu ele geçirilmişti. Eğer farklı servislerde aynı parolayı kullanıyorsanız, güvenliğiniz açısından parolalarınızı güncellemeniz hayati önem taşıyor. Özellikle geçmişte kullandığınız linkedin parolanızı hem linkedin hem de farklı hesaplarınız için kullanmaktan vazgeçmeli, kolay tahmin edilebilir parolalardan uzak durmalısınız.",
            "content_html": "<p>Geçtiğimiz yıl Linkedin veritabanı hacklenmiş ve bu veritabanı uzunca bir süre torrent aracılığıyla elden ele dolaşmıştı. Uzunca bir süre bu olay gerek sosyal medya gerek teknoloji forumlarında konuşulmuş ve zamanla unutulmuştu. Ancak geçtiğimiz aylarda Microsoft’un Linkedin’i satın aldığını duyurması üzerine bu meşhur veritabanı tekrardan torrent paylaşımlarında boy göstermeye başladı. Bu ele geçirme ile birlikte yaklaşık olarak milyonlarca kullanıcının e-mail ve linkedin hesap bilgilerinin yanısıra parolaları da rahatlıkla erişilebilir bir formatta yine rahatlıkla erişilebilir noktalarda bulunuyor. Ortaya çıktığı dönemde Linkedin’e ait olduğu iddia edilen ve milyonlarca kullanıcının bilgisini içeren veritabanı dark web üzerinden 5 Bitcoin karşılığında satışa sunulmuştu.</p><p><img src=\"/assets/images/post/linkedin-db-for-sale.png\" alt=\"Linkedin DB İlanı\" title=\"Linkedin DB İlanı\" /></p><p>Ele geçirilen veritabanında Linkedin kullanıcılarının -en önemli olarak- e-mail ve parola bilgileri yer alıyordu. Parolalar şifrelenmemiş bir şekilde tutulmasa da, parolaların salt kullanılmadan ham bir şekilde SHA1 algoritması ile hashlenerek tutulduğu anlaşılınca parolaların %90’ı 72 saat içerisinde çözülmüştü.</p><p><strong>Not:</strong> Hash algoritmaları şifreleme algoritmaları değildir. Kabaca tek yönlü şifreleme işlemlerinde pratikte yaygın olarak kullanılmaktadır. Veritabanında kullanıcı parolasının hash değeri tutuluyorsa bir şifreleme-çözümleme yapılmaz, sadece kullanıcının giriş yaptığı parolasının hash değeri karşılaştırılır.</p><p>Linkedin veritabanından elde edilen parolalar ile geçtiğimiz ay Mark Zuckerberg’in Twitter hesabıda aynı parolayı kullanması sonucu ele geçirilmişti. Eğer farklı servislerde aynı parolayı kullanıyorsanız, güvenliğiniz açısından parolalarınızı güncellemeniz hayati önem taşıyor. Özellikle geçmişte kullandığınız linkedin parolanızı hem linkedin hem de farklı hesaplarınız için kullanmaktan vazgeçmeli, kolay tahmin edilebilir parolalardan uzak durmalısınız.</p>",
            "url": "https://hakan.io/linkedin-parolalarinizi-kullanmaktan-vazgecin/",
            
            
            
            "tags": ["linkedin","parola","güvenlik"],
            
            "date_published": "2016-10-22T03:00:00+03:00",
            "date_modified": "2016-10-22T03:00:00+03:00",
            
                "author": "Hakan"
            
        },
    
        {
            "id": "https://hakan.io/wifi-sinyalleri-ile-duygu-durum-tespiti/",
            "title": "Wifi Sinyalleri İle Duygu Durum Tespiti",
            "summary": null,
            "content_text": "Bugün kendinizi nasıl hissediyorsunuz?Düşünmenize gerek yok, WiFi routerınız sizin yerinize cevap verebilir. MIT Bilgisayar Bilimleri ve Yapay Zeka Laboratuvarı (CSAIL) araştırmacıları WiFi sinyallerini kullanarak duygu durum tespiti yapmayı başardılar. WiFi sinyallerinin insan vücudu üzerindeki yansımaları takip edilerek kişinin mutlu, şaşırmış, üzgün veya kızgın olduğu tespit edilebildi. Makine öğrenmesi kullanılıyor ve kişinin herhangi bir sensör vs. kullanmasına gerek duyulmuyor.Görsel: MIT CSAILDuygu tespit ve analizi çalışma alanlarında, anlık olarak görüntü işleme tekniklerinin kullanıldığı sistemlerin bilgi işlem maliyetleri göz önüne alındığında, radyo dalgalarının daha efektif kullanımı sağlanabilirse çok daha az maliyetlerle daha hızlı analizler gerçekleştirilebilecek.MIT araştırmacıları, benzer teknolojiyi kullanan sistemlerle;  Film yapımcıları ve reklamcılarının oyuncu tepkilerinin gerçek zamanlı olarak takip edilmesi ve iyileştirilmesinde  Depresyon veya bipolar bozuklukların tanısında  Akıllı ev sistemlerinde, ev sıcaklığı, aydınlatması ve otomatik müzik seçiminde etkin olarak kullanabileceğini belirtti.İlgili araştırmaya bu adresten ulaşabilirsiniz.",
            "content_html": "<p>Bugün kendinizi nasıl hissediyorsunuz?</p><p>Düşünmenize gerek yok, WiFi routerınız sizin yerinize cevap verebilir. MIT Bilgisayar Bilimleri ve Yapay Zeka Laboratuvarı (CSAIL) araştırmacıları WiFi sinyallerini kullanarak duygu durum tespiti yapmayı başardılar. WiFi sinyallerinin insan vücudu üzerindeki yansımaları takip edilerek kişinin mutlu, şaşırmış, üzgün veya kızgın olduğu tespit edilebildi. Makine öğrenmesi kullanılıyor ve kişinin herhangi bir sensör vs. kullanmasına gerek duyulmuyor.</p><p><img src=\"/assets/images/post/wifi-emotion-detection.gif\" alt=\"MIT CSAIL WiFi Emotion Recognition\" title=\"MIT CSAIL WiFi Emotion Recognition\" /><em>Görsel: MIT CSAIL</em></p><p>Duygu tespit ve analizi çalışma alanlarında, anlık olarak görüntü işleme tekniklerinin kullanıldığı sistemlerin bilgi işlem maliyetleri göz önüne alındığında, radyo dalgalarının daha efektif kullanımı sağlanabilirse çok daha az maliyetlerle daha hızlı analizler gerçekleştirilebilecek.</p><p>MIT araştırmacıları, benzer teknolojiyi kullanan sistemlerle;</p><ul>  <li>Film yapımcıları ve reklamcılarının oyuncu tepkilerinin gerçek zamanlı olarak takip edilmesi ve iyileştirilmesinde</li>  <li>Depresyon veya bipolar bozuklukların tanısında</li>  <li>Akıllı ev sistemlerinde, ev sıcaklığı, aydınlatması ve otomatik müzik seçiminde etkin olarak kullanabileceğini belirtti.</li></ul><p>İlgili araştırmaya <a href=\"http://eqradio.csail.mit.edu/files/eqradio-paper.pdf\">bu adresten</a> ulaşabilirsiniz.</p>",
            "url": "https://hakan.io/wifi-sinyalleri-ile-duygu-durum-tespiti/",
            
            
            
            "tags": ["wifi","mitcsail","duygu analizi"],
            
            "date_published": "2016-08-22T03:00:00+03:00",
            "date_modified": "2016-08-22T03:00:00+03:00",
            
                "author": "Hakan"
            
        },
    
        {
            "id": "https://hakan.io/linux-uzerinde-mplayer-ile-radyo-yayini-dinlemek/",
            "title": "Linux Üzerinde Mplayer İle Radyo Yayını Dinlemek",
            "summary": null,
            "content_text": "Linux üzerinde radyo yayını dinlemek isteyebilirsiniz. Bunun için vlc,mplayer gibi medya oynatıcıları kullanabilirsiniz. Renkli renkli grafiklerden haz etmeyen biriyseniz mplayer sizin aradığınız şey. Mplayer ile konsol üzerinde radyo yayını dinlemek için;Örnek olarak Özgür radyo stream için “canliyayin.ozgurradyo.com” adresi üzerinden 8100 portunu kullanıyor.mplayer -nolirc http://canliyayin.ozgurradyo.com:8100komutunu kullanmak yeterli.",
            "content_html": "<p>Linux üzerinde radyo yayını dinlemek isteyebilirsiniz. Bunun için vlc,mplayer gibi medya oynatıcıları kullanabilirsiniz. Renkli renkli grafiklerden haz etmeyen biriyseniz mplayer sizin aradığınız şey. Mplayer ile konsol üzerinde radyo yayını dinlemek için;</p><p>Örnek olarak Özgür radyo stream için “canliyayin.ozgurradyo.com” adresi üzerinden 8100 portunu kullanıyor.</p><figure class=\"highlight\"><pre><code class=\"language-bash\" data-lang=\"bash\">mplayer <span class=\"nt\">-nolirc</span> http://canliyayin.ozgurradyo.com:8100</code></pre></figure><p>komutunu kullanmak yeterli.</p>",
            "url": "https://hakan.io/linux-uzerinde-mplayer-ile-radyo-yayini-dinlemek/",
            
            
            
            "tags": ["dinle","how to","konsol","linux","mplayer","nasıl","radio","radyo","stream"],
            
            "date_published": "2013-08-02T06:32:37+03:00",
            "date_modified": "2013-08-02T06:32:37+03:00",
            
                "author": "Hakan"
            
        },
    
        {
            "id": "https://hakan.io/jquery-ui-ve-php-ile-otomatik-tamamlama/",
            "title": "Jquery Ui ve Php İle Otomatik Tamamlama",
            "summary": null,
            "content_text": "Otomatik tamamlama bir çok noktada hem kullanıcının hem programcının işini kolaylaştırıyor. Otomatik tamamlama ile ilgili fazlasıyla jquery plugini mevcut. Biz Jquery ui ile küçük bir örnek yapacağız.Hazırlık:  Öncelikle jquery ui için http://jqueryui.com/download/ adresinden jquery ui download builder aracını kullanarak jquery ui son versiyonunu indiriyoruz. Bizim için lazım olan widgetlardan autocomplete. İndirdiğimiz dosya içerisinden jquery ui javascript dosyası ve jquery ui css dosyası bizim için gerekli olan dosyalar. Tabi ki jquery son versiyon da jquery ui için gerekli.Öncelikle css ve js dosyalarımızı autocomplete kullanacağımız projemize dahil ediyoruz.&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"css/jquery-ui-1.10.3.custom.css\"&gt;&lt;script type=\"text/javascript\" src=\"js/jquery-ui-1.10.3.custom.min.js\"&gt;&lt;/script&gt;&lt;input type=\"text\" id=\"search\" name=\"search\" &gt;Autocomplete kullanacağımız input alanı için şöyle bir yol izlememiz gerekiyor; $(function() {     $( \"#search\" ).autocomplete({      source: function( request, response ) {        $.ajax({          url: \"search.php\",          dataType: \"json\",          data: {\t\tterm: request.term          },          success: function( data ) {            response( $.map( data, function( item ) {              return {                label: item,                value: item              }            }));          }        });      },    });});Yaptığımız aslında basitçe bir ajax requestin input alanına her karakter girilince tetiklenmesini sağlamak. Search idsine sahip input alanına her girilen karakter tekrar ajax isteği başlatıyor ve search.php sayfamıza parametre geçerek bize bir json verisi döndürüyor. Yani örneğin kullanıcının “ali” kelimesini aratacağını düşünelim;      Kullanıcı a harfine bastığında search.php?term=a        Kullanıcı l harfine bastığında search.php?term=al        Kullanıcı i harfine bastığında search.php?term=ali sayfasına istekte bulunacak ve bize search.php sayfamızdan bir json verisi dönecek.  Search.php sayfamızı basitçe şöyle kurgulayabiliriz. $options = array();$term    = $_GET['term'];$results = $this-&gt;db-&gt;get_results('SELECT name FROM user WHERE name LIKE '$term%''); //Kullandığımız kütüphaneye göre veritabanında arama yapıyoruzforeach($results as $k=&gt;$v):{   $options[] = $v-&gt;name;}echo json_encode($options);Search.php sayfamızda gelen parametreye göre veritabanımızda arama yapıyoruz ve sonucu json verisi olarak ekrana basıyoruz. Ajax olayı da bu sayede json verisini geri sonuç olarak alıyor ve input alanında otomatik tamamlama verisi olarak kullanıyor.",
            "content_html": "<p>Otomatik tamamlama bir çok noktada hem kullanıcının hem programcının işini kolaylaştırıyor. Otomatik tamamlama ile ilgili fazlasıyla jquery plugini mevcut. Biz Jquery ui ile küçük bir örnek yapacağız.</p><p>Hazırlık:</p><ul>  <li>Öncelikle jquery ui için http://jqueryui.com/download/ adresinden jquery ui download builder aracını kullanarak jquery ui son versiyonunu indiriyoruz. Bizim için lazım olan widgetlardan autocomplete. İndirdiğimiz dosya içerisinden jquery ui javascript dosyası ve jquery ui css dosyası bizim için gerekli olan dosyalar. Tabi ki jquery son versiyon da jquery ui için gerekli.<!--more--></li></ul><p>Öncelikle css ve js dosyalarımızı autocomplete kullanacağımız projemize dahil ediyoruz.</p><figure class=\"highlight\"><pre><code class=\"language-php\" data-lang=\"php\"><span class=\"nt\">&lt;link</span> <span class=\"na\">rel=</span><span class=\"s\">\"stylesheet\"</span> <span class=\"na\">type=</span><span class=\"s\">\"text/css\"</span> <span class=\"na\">href=</span><span class=\"s\">\"css/jquery-ui-1.10.3.custom.css\"</span><span class=\"nt\">&gt;</span><span class=\"nt\">&lt;script </span><span class=\"na\">type=</span><span class=\"s\">\"text/javascript\"</span> <span class=\"na\">src=</span><span class=\"s\">\"js/jquery-ui-1.10.3.custom.min.js\"</span><span class=\"nt\">&gt;&lt;/script&gt;</span><span class=\"nt\">&lt;input</span> <span class=\"na\">type=</span><span class=\"s\">\"text\"</span> <span class=\"na\">id=</span><span class=\"s\">\"search\"</span> <span class=\"na\">name=</span><span class=\"s\">\"search\"</span> <span class=\"nt\">&gt;</span></code></pre></figure><p>Autocomplete kullanacağımız input alanı için şöyle bir yol izlememiz gerekiyor;</p><figure class=\"highlight\"><pre><code class=\"language-php\" data-lang=\"php\"> <span class=\"err\">$</span><span class=\"p\">(</span><span class=\"k\">function</span><span class=\"p\">()</span> <span class=\"p\">{</span>     <span class=\"err\">$</span><span class=\"p\">(</span> <span class=\"s2\">\"#search\"</span> <span class=\"p\">)</span><span class=\"mf\">.</span><span class=\"nf\">autocomplete</span><span class=\"p\">({</span>      <span class=\"n\">source</span><span class=\"o\">:</span> <span class=\"k\">function</span><span class=\"p\">(</span> <span class=\"kt\">request</span><span class=\"p\">,</span> <span class=\"kt\">response</span> <span class=\"p\">)</span> <span class=\"p\">{</span>        <span class=\"err\">$</span><span class=\"mf\">.</span><span class=\"nf\">ajax</span><span class=\"p\">({</span>          <span class=\"n\">url</span><span class=\"o\">:</span> <span class=\"s2\">\"search.php\"</span><span class=\"p\">,</span>          <span class=\"n\">dataType</span><span class=\"o\">:</span> <span class=\"s2\">\"json\"</span><span class=\"p\">,</span>          <span class=\"n\">data</span><span class=\"o\">:</span> <span class=\"p\">{</span>\t\t<span class=\"n\">term</span><span class=\"o\">:</span> <span class=\"n\">request</span><span class=\"mf\">.</span><span class=\"n\">term</span>          <span class=\"p\">},</span>          <span class=\"n\">success</span><span class=\"o\">:</span> <span class=\"k\">function</span><span class=\"p\">(</span> <span class=\"kt\">data</span> <span class=\"p\">)</span> <span class=\"p\">{</span>            <span class=\"nf\">response</span><span class=\"p\">(</span> <span class=\"err\">$</span><span class=\"mf\">.</span><span class=\"nf\">map</span><span class=\"p\">(</span> <span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"k\">function</span><span class=\"p\">(</span> <span class=\"kt\">item</span> <span class=\"p\">)</span> <span class=\"p\">{</span>              <span class=\"k\">return</span> <span class=\"p\">{</span>                <span class=\"n\">label</span><span class=\"o\">:</span> <span class=\"n\">item</span><span class=\"p\">,</span>                <span class=\"n\">value</span><span class=\"o\">:</span> <span class=\"n\">item</span>              <span class=\"p\">}</span>            <span class=\"p\">}));</span>          <span class=\"p\">}</span>        <span class=\"p\">});</span>      <span class=\"p\">},</span>    <span class=\"p\">});</span><span class=\"p\">});</span></code></pre></figure><p>Yaptığımız aslında basitçe bir ajax requestin input alanına her karakter girilince tetiklenmesini sağlamak. Search idsine sahip input alanına her girilen karakter tekrar ajax isteği başlatıyor ve search.php sayfamıza parametre geçerek bize bir json verisi döndürüyor. Yani örneğin kullanıcının “ali” kelimesini aratacağını düşünelim;</p><ul>  <li>    <p>Kullanıcı a harfine bastığında search.php?term=a</p>  </li>  <li>    <p>Kullanıcı l harfine bastığında search.php?term=al</p>  </li>  <li>    <p>Kullanıcı i harfine bastığında search.php?term=ali sayfasına istekte bulunacak ve bize search.php sayfamızdan bir json verisi dönecek.</p>  </li></ul><p>Search.php sayfamızı basitçe şöyle kurgulayabiliriz.</p><figure class=\"highlight\"><pre><code class=\"language-php\" data-lang=\"php\"> <span class=\"nv\">$options</span> <span class=\"o\">=</span> <span class=\"k\">array</span><span class=\"p\">();</span><span class=\"nv\">$term</span>    <span class=\"o\">=</span> <span class=\"nv\">$_GET</span><span class=\"p\">[</span><span class=\"s1\">'term'</span><span class=\"p\">];</span><span class=\"nv\">$results</span> <span class=\"o\">=</span> <span class=\"nv\">$this</span><span class=\"o\">-&gt;</span><span class=\"n\">db</span><span class=\"o\">-&gt;</span><span class=\"nf\">get_results</span><span class=\"p\">(</span><span class=\"s1\">'SELECT name FROM user WHERE name LIKE '</span><span class=\"nv\">$term</span><span class=\"o\">%</span><span class=\"s1\">''</span><span class=\"p\">);</span> <span class=\"c1\">//Kullandığımız kütüphaneye göre veritabanında arama yapıyoruz</span><span class=\"k\">foreach</span><span class=\"p\">(</span><span class=\"nv\">$results</span> <span class=\"k\">as</span> <span class=\"nv\">$k</span><span class=\"o\">=&gt;</span><span class=\"nv\">$v</span><span class=\"p\">)</span><span class=\"o\">:</span><span class=\"p\">{</span>   <span class=\"nv\">$options</span><span class=\"p\">[]</span> <span class=\"o\">=</span> <span class=\"nv\">$v</span><span class=\"o\">-&gt;</span><span class=\"n\">name</span><span class=\"p\">;</span><span class=\"p\">}</span><span class=\"k\">echo</span> <span class=\"nb\">json_encode</span><span class=\"p\">(</span><span class=\"nv\">$options</span><span class=\"p\">);</span></code></pre></figure><p>Search.php sayfamızda gelen parametreye göre veritabanımızda arama yapıyoruz ve sonucu json verisi olarak ekrana basıyoruz. Ajax olayı da bu sayede json verisini geri sonuç olarak alıyor ve input alanında otomatik tamamlama verisi olarak kullanıyor.</p>",
            "url": "https://hakan.io/jquery-ui-ve-php-ile-otomatik-tamamlama/",
            
            
            
            "tags": ["autocomplete","google","javascript ile otomatik","jquery","jquery ui","nasıl","otomatik","php ile","php ile otomatik tamamlama","tamamlama","yapılır","yapımı"],
            
            "date_published": "2013-07-27T21:19:32+03:00",
            "date_modified": "2013-07-27T21:19:32+03:00",
            
                "author": "Hakan"
            
        },
    
        {
            "id": "https://hakan.io/linux-uzerinde-topluca-dosya-uzantisi-degistirme/",
            "title": "Linux Üzerinde Topluca Dosya Uzantısı Değiştirme",
            "summary": null,
            "content_text": "Linux üzerinde bir dizin içinde bulunan belirli dosya uzantılarını değiştirmek, örnek olarak .html uzantılarını .htm olarak değiştirmek için;rename s/.html/.htm/ *.html",
            "content_html": "<p>Linux üzerinde bir dizin içinde bulunan belirli dosya uzantılarını değiştirmek, örnek olarak .html uzantılarını .htm olarak değiştirmek için;</p><figure class=\"highlight\"><pre><code class=\"language-bash\" data-lang=\"bash\">rename s/.html/.htm/ <span class=\"k\">*</span>.html</code></pre></figure>",
            "url": "https://hakan.io/linux-uzerinde-topluca-dosya-uzantisi-degistirme/",
            
            
            
            "tags": ["değiştirme","dosya","içindeki","isim","klasör","linux","toplu","uzantı"],
            
            "date_published": "2013-07-18T18:39:15+03:00",
            "date_modified": "2013-07-18T18:39:15+03:00",
            
                "author":  {
                "name": "Hakan Torun",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://hakan.io/c-socket-programlama-client-server-uygulamasi/",
            "title": "C Socket Programlama - Client / Server Uygulaması",
            "summary": null,
            "content_text": "Bu yazımızda C programlama dili ile Linux üzerinde, örnek olması açısından iki uygulamanın haberleşmesini sağlayacağız. Socket, basitçe iki prosesin TCP/IP protokolü üzerinden haberleşmesi için açılan kapı olarak tanımlayabiliriz. Network üzerinde veri aktarımı için öncelikle socket() metoduyla bir socket açmamız, bu sockete de bind() metodu ile bir port numarası atamalıyız. Socketler listen() çağrısıyla bağlantıları dinler, accept() metoduyla bağlantıları kabul eder. Socketler connect() çağrısı ile belirtilen adrese bağlantı sağlar. Socketler send() metoduyla veri gönderir, recv() metoduyla veri alır.Şimdi basit olarak clientın servera bağlanıp bir mesaj aldığını kurgulayalım. Server için;      socket() ile bir socket oluşturulacak        bind() ile sockete bir port bağlanacak        listen() ile bağlanan port dinlenecek        accept() ile varsa bağlantı kabul edilecek        send() ile kabul edilen bağlantıya veri gönderilecek        close() ile kabul edilen bağlantı kapatılacak.  Client için;      socket() ile bir socket oluşturulacak        connect() ile belirtilen adrese bağlantı isteği gönderecek ve bağlanacak        recv() ile bağlandığı adresten veri alacak.  Örnek uygulamada, client server’a bağlandığı zaman server client’a “Hello Client!” mesajı gönderecek ve client bu mesajı alacaktır.Server.c ve client.c dosyaları derlendikten sonra ilgili dizinde ./server komutu ile server uygulaması başlatılır, ./client 127.0.0.1 komutu ile client uygulaması başlatılır. Örnek uygulamada port numarası olarak 7841 verdik. Tabi bu komutlar client ve server uygulamalarının aynı bilgisayar üzerinde koştuğu durumda geçerli.Server.c #include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;int main(int argc, char *argv[]){    int listenfd = 0, connfd = 0;    struct sockaddr_in serv_addr;     char sendBuff[1025];    listenfd = socket(AF_INET, SOCK_STREAM, 0);    memset(&amp;#038;serv_addr, '0', sizeof(serv_addr));    memset(sendBuff, '0', sizeof(sendBuff));     serv_addr.sin_family = AF_INET;    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);    serv_addr.sin_port = htons(7841);     bind(listenfd, (struct sockaddr*)&amp;#038;serv_addr, sizeof(serv_addr));     listen(listenfd, 10);     while(1)    {        connfd = accept(listenfd, (struct sockaddr*)NULL, NULL); \t\tchar data[]=\"Hello Client! \\n\";\t\tsend(connfd, data, strlen(data)+1, 0);\t\t        close(connfd);        sleep(1);     }}Client.c    #include &lt;sys/socket.h&gt;#include &lt;sys/types.h&gt;#include &lt;netinet/in.h&gt;#include &lt;netdb.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;arpa/inet.h&gt; int main(int argc, char *argv[]){    int sockfd = 0, n = 0;    char recvBuff[1024];    struct sockaddr_in serv_addr;     if(argc != 2)    {        printf(\"\\n Usage: %s &lt;ip of server&gt; \\n\",argv[0]);        return 1;    }     memset(recvBuff, '0',sizeof(recvBuff));    if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)    {        printf(\"\\n Error : Could not create socket \\n\");        return 1;    }     memset(&amp;#038;serv_addr, '0', sizeof(serv_addr));     serv_addr.sin_family = AF_INET;    serv_addr.sin_port = htons(7841);     if(inet_pton(AF_INET, argv[1], &amp;#038;serv_addr.sin_addr)&lt;=0)    {        printf(\"\\n inet_pton error occured\\n\");        return 1;    }     if( connect(sockfd, (struct sockaddr *)&amp;#038;serv_addr, sizeof(serv_addr)) &lt; 0)    {       printf(\"\\n Error : Connect Failed \\n\");       return 1;    }     while ( (n = read(sockfd, recvBuff, sizeof(recvBuff)-1)) &gt; 0)    {        recvBuff[n] = 0;        if(fputs(recvBuff, stdout) == EOF)        {            printf(\"\\n Error : Fputs error\\n\");        }    }     if(n &lt; 0)    {        printf(\"\\n Read error \\n\");    }     return 0;}",
            "content_html": "<p>Bu yazımızda C programlama dili ile Linux üzerinde, örnek olması açısından iki uygulamanın haberleşmesini sağlayacağız. Socket, basitçe iki prosesin TCP/IP protokolü üzerinden haberleşmesi için açılan kapı olarak tanımlayabiliriz. Network üzerinde veri aktarımı için öncelikle socket() metoduyla bir socket açmamız, bu sockete de bind() metodu ile bir port numarası atamalıyız. Socketler listen() çağrısıyla bağlantıları dinler, accept() metoduyla bağlantıları kabul eder. Socketler connect() çağrısı ile belirtilen adrese bağlantı sağlar. Socketler send() metoduyla veri gönderir, recv() metoduyla veri alır.</p><p>Şimdi basit olarak clientın servera bağlanıp bir mesaj aldığını kurgulayalım. Server için;</p><ul>  <li>    <p>socket() ile bir socket oluşturulacak</p>  </li>  <li>    <p>bind() ile sockete bir port bağlanacak</p>  </li>  <li>    <p>listen() ile bağlanan port dinlenecek</p>  </li>  <li>    <p>accept() ile varsa bağlantı kabul edilecek</p>  </li>  <li>    <p>send() ile kabul edilen bağlantıya veri gönderilecek</p>  </li>  <li>    <p>close() ile kabul edilen bağlantı kapatılacak.</p>  </li></ul><p>Client için;</p><ul>  <li>    <p>socket() ile bir socket oluşturulacak</p>  </li>  <li>    <p>connect() ile belirtilen adrese bağlantı isteği gönderecek ve bağlanacak</p>  </li>  <li>    <p>recv() ile bağlandığı adresten veri alacak.</p>  </li></ul><p>Örnek uygulamada, client server’a bağlandığı zaman server client’a “Hello Client!” mesajı gönderecek ve client bu mesajı alacaktır.</p><p>Server.c ve client.c dosyaları derlendikten sonra ilgili dizinde ./server komutu ile server uygulaması başlatılır, ./client 127.0.0.1 komutu ile client uygulaması başlatılır. Örnek uygulamada port numarası olarak 7841 verdik. Tabi bu komutlar client ve server uygulamalarının aynı bilgisayar üzerinde koştuğu durumda geçerli.</p><p>Server.c</p><figure class=\"highlight\"><pre><code class=\"language-php\" data-lang=\"php\"> <span class=\"c1\">#include &lt;sys/socket.h&gt;</span><span class=\"c1\">#include &lt;netinet/in.h&gt;</span><span class=\"c1\">#include &lt;arpa/inet.h&gt;</span><span class=\"c1\">#include &lt;stdio.h&gt;</span><span class=\"c1\">#include &lt;stdlib.h&gt;</span><span class=\"c1\">#include &lt;unistd.h&gt;</span><span class=\"c1\">#include &lt;errno.h&gt;</span><span class=\"c1\">#include &lt;string.h&gt;</span><span class=\"c1\">#include &lt;sys/types.h&gt;</span><span class=\"n\">int</span> <span class=\"nb\">main</span><span class=\"p\">(</span><span class=\"n\">int</span> <span class=\"n\">argc</span><span class=\"p\">,</span> <span class=\"n\">char</span> <span class=\"o\">*</span><span class=\"n\">argv</span><span class=\"p\">[])</span><span class=\"p\">{</span>    <span class=\"n\">int</span> <span class=\"n\">listenfd</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">connfd</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>    <span class=\"n\">struct</span> <span class=\"n\">sockaddr_in</span> <span class=\"n\">serv_addr</span><span class=\"p\">;</span>     <span class=\"n\">char</span> <span class=\"n\">sendBuff</span><span class=\"p\">[</span><span class=\"mi\">1025</span><span class=\"p\">];</span>    <span class=\"n\">listenfd</span> <span class=\"o\">=</span> <span class=\"nf\">socket</span><span class=\"p\">(</span><span class=\"no\">AF_INET</span><span class=\"p\">,</span> <span class=\"no\">SOCK_STREAM</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">);</span>    <span class=\"nf\">memset</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"c1\">#038;serv_addr, '0', sizeof(serv_addr));</span>    <span class=\"nf\">memset</span><span class=\"p\">(</span><span class=\"n\">sendBuff</span><span class=\"p\">,</span> <span class=\"s1\">'0'</span><span class=\"p\">,</span> <span class=\"nb\">sizeof</span><span class=\"p\">(</span><span class=\"n\">sendBuff</span><span class=\"p\">));</span>     <span class=\"n\">serv_addr</span><span class=\"mf\">.</span><span class=\"n\">sin_family</span> <span class=\"o\">=</span> <span class=\"no\">AF_INET</span><span class=\"p\">;</span>    <span class=\"n\">serv_addr</span><span class=\"mf\">.</span><span class=\"n\">sin_addr</span><span class=\"mf\">.</span><span class=\"n\">s_addr</span> <span class=\"o\">=</span> <span class=\"nf\">htonl</span><span class=\"p\">(</span><span class=\"no\">INADDR_ANY</span><span class=\"p\">);</span>    <span class=\"n\">serv_addr</span><span class=\"mf\">.</span><span class=\"n\">sin_port</span> <span class=\"o\">=</span> <span class=\"nf\">htons</span><span class=\"p\">(</span><span class=\"mi\">7841</span><span class=\"p\">);</span>     <span class=\"nf\">bind</span><span class=\"p\">(</span><span class=\"n\">listenfd</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">struct</span> <span class=\"n\">sockaddr</span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"o\">&amp;</span><span class=\"c1\">#038;serv_addr, sizeof(serv_addr)); </span>    <span class=\"nf\">listen</span><span class=\"p\">(</span><span class=\"n\">listenfd</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">);</span>     <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>    <span class=\"p\">{</span>        <span class=\"n\">connfd</span> <span class=\"o\">=</span> <span class=\"nf\">accept</span><span class=\"p\">(</span><span class=\"n\">listenfd</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">struct</span> <span class=\"n\">sockaddr</span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"kc\">NULL</span><span class=\"p\">,</span> <span class=\"kc\">NULL</span><span class=\"p\">);</span> \t\t<span class=\"n\">char</span> <span class=\"n\">data</span><span class=\"p\">[]</span><span class=\"o\">=</span><span class=\"s2\">\"Hello Client! </span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">;</span>\t\t<span class=\"nf\">send</span><span class=\"p\">(</span><span class=\"n\">connfd</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"nb\">strlen</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\t\t        <span class=\"nf\">close</span><span class=\"p\">(</span><span class=\"n\">connfd</span><span class=\"p\">);</span>        <span class=\"nb\">sleep</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span>     <span class=\"p\">}</span><span class=\"p\">}</span></code></pre></figure><p>Client.c</p><figure class=\"highlight\"><pre><code class=\"language-php\" data-lang=\"php\">    <span class=\"c1\">#include &lt;sys/socket.h&gt;</span><span class=\"c1\">#include &lt;sys/types.h&gt;</span><span class=\"c1\">#include &lt;netinet/in.h&gt;</span><span class=\"c1\">#include &lt;netdb.h&gt;</span><span class=\"c1\">#include &lt;stdio.h&gt;</span><span class=\"c1\">#include &lt;string.h&gt;</span><span class=\"c1\">#include &lt;stdlib.h&gt;</span><span class=\"c1\">#include &lt;unistd.h&gt;</span><span class=\"c1\">#include &lt;errno.h&gt;</span><span class=\"c1\">#include &lt;arpa/inet.h&gt; </span><span class=\"n\">int</span> <span class=\"nb\">main</span><span class=\"p\">(</span><span class=\"n\">int</span> <span class=\"n\">argc</span><span class=\"p\">,</span> <span class=\"n\">char</span> <span class=\"o\">*</span><span class=\"n\">argv</span><span class=\"p\">[])</span><span class=\"p\">{</span>    <span class=\"n\">int</span> <span class=\"n\">sockfd</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>    <span class=\"n\">char</span> <span class=\"n\">recvBuff</span><span class=\"p\">[</span><span class=\"mi\">1024</span><span class=\"p\">];</span>    <span class=\"n\">struct</span> <span class=\"n\">sockaddr_in</span> <span class=\"n\">serv_addr</span><span class=\"p\">;</span>     <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">argc</span> <span class=\"o\">!=</span> <span class=\"mi\">2</span><span class=\"p\">)</span>    <span class=\"p\">{</span>        <span class=\"nb\">printf</span><span class=\"p\">(</span><span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\"> Usage: %s &lt;ip of server&gt; </span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">,</span><span class=\"n\">argv</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]);</span>        <span class=\"k\">return</span> <span class=\"mi\">1</span><span class=\"p\">;</span>    <span class=\"p\">}</span>     <span class=\"nf\">memset</span><span class=\"p\">(</span><span class=\"n\">recvBuff</span><span class=\"p\">,</span> <span class=\"s1\">'0'</span><span class=\"p\">,</span><span class=\"nb\">sizeof</span><span class=\"p\">(</span><span class=\"n\">recvBuff</span><span class=\"p\">));</span>    <span class=\"k\">if</span><span class=\"p\">((</span><span class=\"n\">sockfd</span> <span class=\"o\">=</span> <span class=\"nf\">socket</span><span class=\"p\">(</span><span class=\"no\">AF_INET</span><span class=\"p\">,</span> <span class=\"no\">SOCK_STREAM</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">))</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span>    <span class=\"p\">{</span>        <span class=\"nb\">printf</span><span class=\"p\">(</span><span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\"> Error : Could not create socket </span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">);</span>        <span class=\"k\">return</span> <span class=\"mi\">1</span><span class=\"p\">;</span>    <span class=\"p\">}</span>     <span class=\"nf\">memset</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"c1\">#038;serv_addr, '0', sizeof(serv_addr)); </span>    <span class=\"n\">serv_addr</span><span class=\"mf\">.</span><span class=\"n\">sin_family</span> <span class=\"o\">=</span> <span class=\"no\">AF_INET</span><span class=\"p\">;</span>    <span class=\"n\">serv_addr</span><span class=\"mf\">.</span><span class=\"n\">sin_port</span> <span class=\"o\">=</span> <span class=\"nf\">htons</span><span class=\"p\">(</span><span class=\"mi\">7841</span><span class=\"p\">);</span>     <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"nb\">inet_pton</span><span class=\"p\">(</span><span class=\"no\">AF_INET</span><span class=\"p\">,</span> <span class=\"n\">argv</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"o\">&amp;</span><span class=\"c1\">#038;serv_addr.sin_addr)&lt;=0)</span>    <span class=\"p\">{</span>        <span class=\"nb\">printf</span><span class=\"p\">(</span><span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\"> inet_pton error occured</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">);</span>        <span class=\"k\">return</span> <span class=\"mi\">1</span><span class=\"p\">;</span>    <span class=\"p\">}</span>     <span class=\"k\">if</span><span class=\"p\">(</span> <span class=\"nf\">connect</span><span class=\"p\">(</span><span class=\"n\">sockfd</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">struct</span> <span class=\"n\">sockaddr</span> <span class=\"o\">*</span><span class=\"p\">)</span><span class=\"o\">&amp;</span><span class=\"c1\">#038;serv_addr, sizeof(serv_addr)) &lt; 0)</span>    <span class=\"p\">{</span>       <span class=\"nb\">printf</span><span class=\"p\">(</span><span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\"> Error : Connect Failed </span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">);</span>       <span class=\"k\">return</span> <span class=\"mi\">1</span><span class=\"p\">;</span>    <span class=\"p\">}</span>     <span class=\"k\">while</span> <span class=\"p\">(</span> <span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"nf\">read</span><span class=\"p\">(</span><span class=\"n\">sockfd</span><span class=\"p\">,</span> <span class=\"n\">recvBuff</span><span class=\"p\">,</span> <span class=\"nb\">sizeof</span><span class=\"p\">(</span><span class=\"n\">recvBuff</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">))</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span>    <span class=\"p\">{</span>        <span class=\"n\">recvBuff</span><span class=\"p\">[</span><span class=\"n\">n</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>        <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"nb\">fputs</span><span class=\"p\">(</span><span class=\"n\">recvBuff</span><span class=\"p\">,</span> <span class=\"n\">stdout</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"no\">EOF</span><span class=\"p\">)</span>        <span class=\"p\">{</span>            <span class=\"nb\">printf</span><span class=\"p\">(</span><span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\"> Error : Fputs error</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">);</span>        <span class=\"p\">}</span>    <span class=\"p\">}</span>     <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span>    <span class=\"p\">{</span>        <span class=\"nb\">printf</span><span class=\"p\">(</span><span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\"> Read error </span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">);</span>    <span class=\"p\">}</span>     <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"p\">}</span></code></pre></figure>",
            "url": "https://hakan.io/c-socket-programlama-client-server-uygulamasi/",
            
            
            
            "tags": ["c ile","c programlama","c programlama ile","c socket programlama","c soket programlama","client server","network programlama","örneği","örnek uygulama","socket","socket nedir","tcp/ip"],
            
            "date_published": "2013-07-18T06:05:30+03:00",
            "date_modified": "2013-07-18T06:05:30+03:00",
            
                "author": "Hakan"
            
        },
    
        {
            "id": "https://hakan.io/linux-konsolda-video-oynatmak",
            "title": "Linux Konsolda Video Oynatmak",
            "summary": null,
            "content_text": "Linux üzerinde, benim gibi konsolda ascii karakterler ile video izlemek isteyen birileri mutlaka vardır. Teknolojide her zaman eskiye özlem duyan ve yaşatmaya çalışanlar için linux üzerinde mplayer ile bunu gerçekleştirmek mümkün. Konsoldamplayer -vo aa video.avikomutuyla istenilen video ascii karakterler ile tabi ki siyah-beyaz olarak konsol üzerinden izlenebilir. Sonuç olarak şöyle bir görüntü ortaya çıkacaktır.",
            "content_html": "<p>Linux üzerinde, benim gibi konsolda ascii karakterler ile video izlemek isteyen birileri mutlaka vardır. Teknolojide her zaman eskiye özlem duyan ve yaşatmaya çalışanlar için linux üzerinde mplayer ile bunu gerçekleştirmek mümkün. Konsolda</p><figure class=\"highlight\"><pre><code class=\"language-bash\" data-lang=\"bash\">mplayer <span class=\"nt\">-vo</span> aa video.avi</code></pre></figure><p>komutuyla istenilen video ascii karakterler ile tabi ki siyah-beyaz olarak konsol üzerinden izlenebilir. Sonuç olarak şöyle bir görüntü ortaya çıkacaktır.</p><p><img src=\"https://hakan.io/assets/images/post/Screenshot.png\" alt=\"Screenshot\" /></p>",
            "url": "https://hakan.io/linux-konsolda-video-oynatmak",
            
            
            
            "tags": ["ASCII Art","Console","Linux","Terminal","Video"],
            
            "date_published": "2013-07-13T05:17:16+03:00",
            "date_modified": "2013-07-13T05:17:16+03:00",
            
                "author":  {
                "name": "Hakan Torun",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://hakan.io/sshfs-kullanimi/",
            "title": "Sshfs Kullanımı",
            "summary": null,
            "content_text": "İki uç sistem arasında dosya transferi çoğu zaman zahmetli bir iştir. Çeşitli dosya aktarım protokolleri bu işler için kullanılmakta. Sshfs ile herhangi bir uç sistemdeki dosya sistemini kendi makinenize bağlayabilirsiniz. SSHFS ile bağlanan dosya sistemi kendi makinenizdeymiş gibi davranır ve üzerinde işlem yapmak gayet kolaydır.Öncelikle kullandığınız paket yöneticisi ile sshfs (Secure Shell Filesystem) kurulumunu gerçekleştiriyoruz. Örnek olarak Ubuntu:apt-get install sshfsKurulum gerçekleştikten sonra konsoldan;sshfs kullanici@bağlanacak_ip:/dizin /localdizin formatında dosya sistemini bağlayabiliriz. Örnek olarak local ağınızdaki 192.168.1.65 ip adresine sahip sisteminize pase kullanıcısı olarak bağlanarak, /var/www dizinini kendi sisteminizde /home/server dizinine bağlayacaksanız;sshsf pase@192.168.1.65:/var/www /home/server komutunu kullanmalısınız. Komut verildikten sonra ssh bağlantısı için onay istenecek ve 192.168.1.65 ip adresindeki sistem için pase kullanıcısının şifresi sorulacaktır. Sonrasında dosya sistemi bağlanacaktır.",
            "content_html": "<p>İki uç sistem arasında dosya transferi çoğu zaman zahmetli bir iştir. Çeşitli dosya aktarım protokolleri bu işler için kullanılmakta. Sshfs ile herhangi bir uç sistemdeki dosya sistemini kendi makinenize bağlayabilirsiniz. SSHFS ile bağlanan dosya sistemi kendi makinenizdeymiş gibi davranır ve üzerinde işlem yapmak gayet kolaydır.</p><p>Öncelikle kullandığınız paket yöneticisi ile sshfs (Secure Shell Filesystem) kurulumunu gerçekleştiriyoruz. Örnek olarak Ubuntu:</p><figure class=\"highlight\"><pre><code class=\"language-bash\" data-lang=\"bash\">apt-get <span class=\"nb\">install </span>sshfs</code></pre></figure><p>Kurulum gerçekleştikten sonra konsoldan;</p><figure class=\"highlight\"><pre><code class=\"language-bash\" data-lang=\"bash\">sshfs kullanici@bağlanacak_ip:/dizin /localdizin formatında dosya sistemini bağlayabiliriz. </code></pre></figure><p>Örnek olarak local ağınızdaki 192.168.1.65 ip adresine sahip sisteminize pase kullanıcısı olarak bağlanarak, /var/www dizinini kendi sisteminizde /home/server dizinine bağlayacaksanız;</p><figure class=\"highlight\"><pre><code class=\"language-bash\" data-lang=\"bash\">sshsf pase@192.168.1.65:/var/www /home/server </code></pre></figure><p>komutunu kullanmalısınız. Komut verildikten sonra ssh bağlantısı için onay istenecek ve 192.168.1.65 ip adresindeki sistem için pase kullanıcısının şifresi sorulacaktır. Sonrasında dosya sistemi bağlanacaktır.</p>",
            "url": "https://hakan.io/sshfs-kullanimi/",
            
            
            
            "tags": ["ssfs","sshfs kullanımı","sshfs nedir","sshfs ubuntu kurulumu"],
            
            "date_published": "2013-03-18T03:58:28+02:00",
            "date_modified": "2013-03-18T03:58:28+02:00",
            
                "author":  {
                "name": "Hakan Torun",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://hakan.io/irssi-konsol-tabanli-irc-client/",
            "title": "Irssi &#8211; Konsol Tabanlı IRC Client",
            "summary": null,
            "content_text": "Irc günümüzde popülerliğini yitirmiş olsa da zamanın en popüler protokollerinden biriydi. Linux kullanıcıları tarafından IRC hala aktif olarak kullanılıyor.Linux üzerinde Xchat, Windows üzerinde Mirc en popüler clientlar. Linux üzerinde konsol tabanlı Irssi ise görevini başarıyla yerine getiren bir IRC client.Dağıtımınıza göre paket yöneticinizden kurulumu tamamladıktan sonra, konsolda “irssi” komutuyla irssi başlatılabilir. Öncelikle bir irc server ekleme işlemi, örnek olarak irc.freenode.net ve kısa isim olarak freenode ile;/server add -network freenode irc.freenode.netİlgili sunucuya bir kanal eklemek için, örnek olarak freenode ismini verdiğimiz sunucuya #perl kanalı;/channel add #perl freenode#perl kanalına katılmak için/join #perlkomutu kullanılabilir. Irssi her başlangıçta yeniden ekleme işlemlerini tekrarlamamak için;/server add -auto -network freenode irc.freenode.net  /network add -nick username  /channel add -auto #perl freenode  /channel add -auto #kanalismi freenode  /save  /quitkomutları ile ~/.irssi/config dosyasına kayıt işlemi gerçekleştirilebilir ve irssi başlangıcında otomatik olarak server ve kanal ekleme işlemleri ile birlikte nick belirleme işlemi gerçekleştirilebilir.Son olarak Irssi ekran görüntüsü;",
            "content_html": "<p>Irc günümüzde popülerliğini yitirmiş olsa da zamanın en popüler protokollerinden biriydi. Linux kullanıcıları tarafından IRC hala aktif olarak kullanılıyor.</p><p>Linux üzerinde Xchat, Windows üzerinde Mirc en popüler clientlar. Linux üzerinde konsol tabanlı Irssi ise görevini başarıyla yerine getiren bir IRC client.</p><p>Dağıtımınıza göre paket yöneticinizden kurulumu tamamladıktan sonra, konsolda “irssi” komutuyla irssi başlatılabilir. Öncelikle bir irc server ekleme işlemi, örnek olarak irc.freenode.net ve kısa isim olarak freenode ile;</p><figure class=\"highlight\"><pre><code class=\"language-bash\" data-lang=\"bash\">/server add <span class=\"nt\">-network</span> freenode irc.freenode.net</code></pre></figure><p>İlgili sunucuya bir kanal eklemek için, örnek olarak freenode ismini verdiğimiz sunucuya #perl kanalı;</p><figure class=\"highlight\"><pre><code class=\"language-ruby\" data-lang=\"ruby\"><span class=\"sr\">/channel add #perl freenode</span></code></pre></figure><p>#perl kanalına katılmak için</p><figure class=\"highlight\"><pre><code class=\"language-ruby\" data-lang=\"ruby\"><span class=\"sr\">/join #perl</span></code></pre></figure><p>komutu kullanılabilir. Irssi her başlangıçta yeniden ekleme işlemlerini tekrarlamamak için;</p><figure class=\"highlight\"><pre><code class=\"language-bash\" data-lang=\"bash\">/server add <span class=\"nt\">-auto</span> <span class=\"nt\">-network</span> freenode irc.freenode.net  /network add <span class=\"nt\">-nick</span> username  /channel add <span class=\"nt\">-auto</span> <span class=\"c\">#perl freenode</span>  /channel add <span class=\"nt\">-auto</span> <span class=\"c\">#kanalismi freenode</span>  /save  /quit</code></pre></figure><p>komutları ile ~/.irssi/config dosyasına kayıt işlemi gerçekleştirilebilir ve irssi başlangıcında otomatik olarak server ve kanal ekleme işlemleri ile birlikte nick belirleme işlemi gerçekleştirilebilir.</p><p>Son olarak Irssi ekran görüntüsü;</p>",
            "url": "https://hakan.io/irssi-konsol-tabanli-irc-client/",
            
            
            
            "tags": ["archlinux","client","irc","irssi","komut","komutları","kullanımı","kurulum","linux","setup"],
            
            "date_published": "2013-01-13T03:30:14+02:00",
            "date_modified": "2013-01-13T03:30:14+02:00",
            
                "author": "Hakan"
            
        },
    
        {
            "id": "https://hakan.io/raspberry-pi-python-gpio-kurulumu/",
            "title": "Raspberry Pi &#8211; Python GPIO Kurulumu",
            "summary": null,
            "content_text": "Raspberry Pi Gpio pinlerini Python ile kullanabilmek için Python Gpio modülünü kurmak gerekiyor. Kurulum için terminalden sıkıştırılmış modül arşivinin indirileceği dizine geçtikten sonra sırasıyla aşağıdaki komuları işletmek yeterli.$ wget http://pypi.python.org/packages/source/R/RPi.GPIO/RPi.GPIO-0.1.0.tar.gz  $ tar zxf RPi.GPIO-0.1.0.tar.gz  $ cd RPi.GPIO-0.1.0  $ sudo python setup.py install",
            "content_html": "<p>Raspberry Pi Gpio pinlerini Python ile kullanabilmek için Python Gpio modülünü kurmak gerekiyor. Kurulum için terminalden sıkıştırılmış modül arşivinin indirileceği dizine geçtikten sonra sırasıyla aşağıdaki komuları işletmek yeterli.</p><figure class=\"highlight\"><pre><code class=\"language-bash\" data-lang=\"bash\"><span class=\"nv\">$ </span>wget http://pypi.python.org/packages/source/R/RPi.GPIO/RPi.GPIO-0.1.0.tar.gz  <span class=\"nv\">$ </span><span class=\"nb\">tar </span>zxf RPi.GPIO-0.1.0.tar.gz  <span class=\"nv\">$ </span><span class=\"nb\">cd </span>RPi.GPIO-0.1.0  <span class=\"nv\">$ </span><span class=\"nb\">sudo </span>python setup.py <span class=\"nb\">install</span></code></pre></figure>",
            "url": "https://hakan.io/raspberry-pi-python-gpio-kurulumu/",
            
            
            
            "tags": ["gpio","kurulum","pypi","python","raspberry","raspberry pi","raspbian"],
            
            "date_published": "2012-09-29T05:49:37+03:00",
            "date_modified": "2012-09-29T05:49:37+03:00",
            
                "author": "Hakan"
            
        },
    
        {
            "id": "https://hakan.io/raspberry-pi/",
            "title": "Raspberry Pi",
            "summary": null,
            "content_text": "Dünyaynın en ucuz bilgisayarı olarak geçen Raspberry Pi elime geçeli bir hayli zaman oldu. Yeni yeni vakit bulabiliyor ve deneysel çalışmalar yapıyorum. Özelliklerini kısaca yazacak olursak;      800 Mhz Arm İşlemci        256 Mb Ram        Hdmi – Rca Video – 2x Usb – Ethernet ve Ses çıkışları        Sd Card  Cihazda dahili hafıza bulunmuyor. Sd kart üzerinden boot etmeniz gerekiyor ve şu anda birkaç farklı distro stabil olarak çalışıyor(muş). Debian tabanlı Raspbian ve Arch tabanlı dağıtım Raspberrypi.org’da mevcut. İlk olarak Raspbian kurulumu gerçekleştirdim. Çalışmalarımı vakit buldukça paylaşacağım. Umarım :)",
            "content_html": "<p>Dünyaynın en ucuz bilgisayarı olarak geçen Raspberry Pi elime geçeli bir hayli zaman oldu. Yeni yeni vakit bulabiliyor ve deneysel çalışmalar yapıyorum. Özelliklerini kısaca yazacak olursak;</p><ul>  <li>    <p>800 Mhz Arm İşlemci</p>  </li>  <li>    <p>256 Mb Ram</p>  </li>  <li>    <p>Hdmi – Rca Video – 2x Usb – Ethernet ve Ses çıkışları</p>  </li>  <li>    <p>Sd Card</p>  </li></ul><p>Cihazda dahili hafıza bulunmuyor. Sd kart üzerinden boot etmeniz gerekiyor ve şu anda birkaç farklı distro stabil olarak çalışıyor(muş). Debian tabanlı Raspbian ve Arch tabanlı dağıtım Raspberrypi.org’da mevcut. İlk olarak Raspbian kurulumu gerçekleştirdim. Çalışmalarımı vakit buldukça paylaşacağım. Umarım :)</p>",
            "url": "https://hakan.io/raspberry-pi/",
            
            
            
            "tags": ["pi","raspberry","raspbian"],
            
            "date_published": "2012-09-28T08:31:21+03:00",
            "date_modified": "2012-09-28T08:31:21+03:00",
            
                "author": "Hakan"
            
        },
    
        {
            "id": "https://hakan.io/phpsysinfo-php-server-monitor/",
            "title": "PhpSysInfo &#8211; Php Server Monitor",
            "summary": null,
            "content_text": "Bugünlerde php tabanlı ufak bi server monitor yazma niyetim var. Aslında bana lazım olan load average değerlerini grafik üzerinde göstermekti. Nitekim bi kahve içene kadar yazıldı. Araştırırken PhpSysInfo isimli betiğe rastladım ve deneyince beğendiğimi söyleyebilirim.Betik için kuruluma gerek yok, direkt olarak http://phpsysinfo.sourceforge.net/ adresinden betiği edinebilirsiniz. Arşivi server dizinine çıkadıktan sonra arşivden çıkardığınız dosyalar arasında config.php.new isimli bir dosya göreceksiniz. Betik çalışmak için bu ayar dosyasına ihtiyaç duyuyor. config.php.new dosya ismini config.php olarak değiştirmeniz acemi kullanıcı için yeterli olacaktır. Zaten config dosyası içerisinde gerekli açıklamlar yapılmış durumda. Bu arada Türkçe desteği ve tema seçenekleri mevcut.Ek olarak kaynakları fazla tüketmemek adına default olarak gelen 1 dakikalık yenileme süresini fazla kısaltmamanızı ve işlemci kullanımını göstermemenizi öneririm.Ekran görüntüsü fikir sahibi olmanıza yardımcı olacaktır.",
            "content_html": "<p>Bugünlerde php tabanlı ufak bi server monitor yazma niyetim var. Aslında bana lazım olan load average değerlerini grafik üzerinde göstermekti. Nitekim bi kahve içene kadar yazıldı. Araştırırken PhpSysInfo isimli betiğe rastladım ve deneyince beğendiğimi söyleyebilirim.</p><p>Betik için kuruluma gerek yok, direkt olarak <a href=\"http://phpsysinfo.sourceforge.net/\">http://phpsysinfo.sourceforge.net/</a> adresinden betiği edinebilirsiniz. Arşivi server dizinine çıkadıktan sonra arşivden çıkardığınız dosyalar arasında config.php.new isimli bir dosya göreceksiniz. Betik çalışmak için bu ayar dosyasına ihtiyaç duyuyor. config.php.new dosya ismini config.php olarak değiştirmeniz acemi kullanıcı için yeterli olacaktır. Zaten config dosyası içerisinde gerekli açıklamlar yapılmış durumda. Bu arada Türkçe desteği ve tema seçenekleri mevcut.</p><p>Ek olarak kaynakları fazla tüketmemek adına default olarak gelen 1 dakikalık yenileme süresini fazla kısaltmamanızı ve işlemci kullanımını göstermemenizi öneririm.</p><p>Ekran görüntüsü fikir sahibi olmanıza yardımcı olacaktır.</p>",
            "url": "https://hakan.io/phpsysinfo-php-server-monitor/",
            
            
            
            "tags": ["load average","php server monitor","phpsysinfo"],
            
            "date_published": "2012-08-09T04:16:31+03:00",
            "date_modified": "2012-08-09T04:16:31+03:00",
            
                "author": "Hakan"
            
        },
    
        {
            "id": "https://hakan.io/tinymce-kullanilan-textareaya-ekleme-yapma/",
            "title": "TinyMCE Kullanılan Textarea&#8217;ya Ekleme Yapma",
            "summary": null,
            "content_text": "TinyMCE kullanışlı bir editör. Web uygulamalarında içeriklerin tekrar elden geçirilmesi hususunu bir nebze olsun hafifleten bir editör. Gel gelelim TinyMCE kullanılan bir alanda manipülasyon yapılması gerektiğinde farklı bir yöntem kullanılması gerektiğinden bihaber yazılımcının canını biraz sıkar.Hemen konuya geçelim;Mesela web uygulamamızın panel kısmından haber ekleme modülünde TinyMCE kullandık ve kullanıcı bu alana butonlar aracılığıyla eklemeler yapmak istedi. Örneğin kullanıcı editörü kullanırken yazı içine resim eklemek istedi. Önce yazının o anki hali tutulacak, her resim ekleme işleminde bu işlem tekrarlanacak ve iş anlamsızlaşacak. Kullanıcı her bir eklemede bir önceki veriyi kısmen kaybedecek. Bu noktada  jquery maalesef pek işe yaramıyor. Şöyle ki;   Şu anki içeriği önbellekle  Eklenen resmi içerikle birlikte basile ekleme yapmaya çalıştığınızda ne yazık ki her eklemede bir önceki veriyi kaybediyoruz. Bu noktada TinyMCE imdadımıza koşuyor vetinyMCE.execCommand(&amp;#039;mceInsertContent&amp;#039;, false, &amp;#039;&amp;lt;img witdh=\"100%\" src=\"http://www.mysite.com/myImage.jpg\"  /&amp;gt;&amp;#039;);tinyMCE.execCommand vasıtası ile yazı içerisine rahatlılla ekleme yapabiliyoruz. Pek tabi resim ekleme dışında her hangi bir içerik eklemek bu yolla mümkün. Bu kullanımı TinyMCE’ye bir image uploader yazarken kullanmak zorunda kaldım. Maalesef TinyMCE image upload eklentisini ücretsiz olarak dağıtmıyor ve bu noktada kendi çözümünüzü üretmeniz ya da ücreti karşılığında almanız gerek.Bu arada yazı başlığı biraz garip oldu galiba. Saat sabah 05:30 idare edelim  ",
            "content_html": "<p>TinyMCE kullanışlı bir editör. Web uygulamalarında içeriklerin tekrar elden geçirilmesi hususunu bir nebze olsun hafifleten bir editör. Gel gelelim TinyMCE kullanılan bir alanda manipülasyon yapılması gerektiğinde farklı bir yöntem kullanılması gerektiğinden bihaber yazılımcının canını biraz sıkar.</p><p>Hemen konuya geçelim;</p><p>Mesela web uygulamamızın panel kısmından haber ekleme modülünde TinyMCE kullandık ve kullanıcı bu alana butonlar aracılığıyla eklemeler yapmak istedi. Örneğin kullanıcı editörü kullanırken yazı içine resim eklemek istedi. Önce yazının o anki hali tutulacak, her resim ekleme işleminde bu işlem tekrarlanacak ve iş anlamsızlaşacak. Kullanıcı her bir eklemede bir önceki veriyi kısmen kaybedecek. Bu noktada  jquery maalesef pek işe yaramıyor. Şöyle ki;</p><p> </p><ul>  <li>Şu anki içeriği önbellekle</li>  <li>Eklenen resmi içerikle birlikte bas</li></ul><p>ile ekleme yapmaya çalıştığınızda ne yazık ki her eklemede bir önceki veriyi kaybediyoruz. Bu noktada TinyMCE imdadımıza koşuyor ve</p><figure class=\"highlight\"><pre><code class=\"language-javascript\" data-lang=\"javascript\"><span class=\"nx\">tinyMCE</span><span class=\"p\">.</span><span class=\"nx\">execCommand</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"err\">#</span><span class=\"mi\">039</span><span class=\"p\">;</span><span class=\"nx\">mceInsertContent</span><span class=\"o\">&amp;</span><span class=\"err\">#</span><span class=\"mi\">039</span><span class=\"p\">;,</span> <span class=\"kc\">false</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"err\">#</span><span class=\"mi\">039</span><span class=\"p\">;</span><span class=\"o\">&amp;</span><span class=\"nx\">lt</span><span class=\"p\">;</span><span class=\"nx\">img</span> <span class=\"nx\">witdh</span><span class=\"o\">=</span><span class=\"dl\">\"</span><span class=\"s2\">100%</span><span class=\"dl\">\"</span> <span class=\"nx\">src</span><span class=\"o\">=</span><span class=\"dl\">\"</span><span class=\"s2\">http://www.mysite.com/myImage.jpg</span><span class=\"dl\">\"</span>  <span class=\"o\">/&amp;</span><span class=\"nx\">gt</span><span class=\"p\">;</span><span class=\"o\">&amp;</span><span class=\"err\">#</span><span class=\"mi\">039</span><span class=\"p\">;);</span></code></pre></figure><p>tinyMCE.execCommand vasıtası ile yazı içerisine rahatlılla ekleme yapabiliyoruz. Pek tabi resim ekleme dışında her hangi bir içerik eklemek bu yolla mümkün. Bu kullanımı TinyMCE’ye bir image uploader yazarken kullanmak zorunda kaldım. Maalesef TinyMCE image upload eklentisini ücretsiz olarak dağıtmıyor ve bu noktada kendi çözümünüzü üretmeniz ya da ücreti karşılığında almanız gerek.</p><p>Bu arada yazı başlığı biraz garip oldu galiba. Saat sabah 05:30 idare edelim  <img src=\"http://www.eksihayaller.com/wp-includes/images/smilies/icon_smile.gif\" alt=\":)\" class=\"wp-smiley\" /></p>",
            "url": "https://hakan.io/tinymce-kullanilan-textareaya-ekleme-yapma/",
            
            
            
            
            
            "date_published": "2012-02-29T05:34:37+02:00",
            "date_modified": "2012-02-29T05:34:37+02:00",
            
                "author": "Hakan"
            
        },
    
        {
            "id": "https://hakan.io/php-session-kullanimi/",
            "title": "PHP Session Kullanımı",
            "summary": null,
            "content_text": "PHP’de kullanıcı oturumlarını yönetmek için birtakım fonksiyon kullanılır. İnternet sitesini ziyaret eden her bir kullanıcı için, sunucu üzerinde bir dosya oluşturulur ve kullanıcı oturumuna ait veriler bu dosya içerisine kaydedilir. Sunucu üzerinde bulunan session dosyası ile ziyaretçinin eşleştirilmesi için ise, istemci üzerinde bir cookie oluşturulur. Tüm bu işlemler için PHP session fonksiyonları ve başlatılmış oturumlar için kullanılan $_SESSION dizisi ile kabaca oturum yönetimi yapılabilir.PHP’de bir oturum başlatmak için en yalın haliyle aşağıdaki gibi bir kod çalıştırılabilir.&lt;?phpsession_start();$username = \"Test\";$_SESSION[\"username\"] = $username;?&gt;Buradaki session_start() fonksiyonuyla yeni bir oturum başlatılır. Oturum başlatıldıktan sonra, oturum verilerinin tutulacağı $_SESSION dizisine, username isimli değişkendeki veri atanır.&lt;?phpsession_start();echo \"Kullanıcı Adı:\".$_SESSION[\"username\"];?&gt;Burada ise session_start() ile oturum başlatılarak daha önce $_SESSION[‘username’] değişkenine atanan veri ekrana yazdırılır.Herhangi bir zaman, oturum sonlandırılmak ve session verileri silinmek istenirse session_destroy() fonksiyonu çalıştırılır.",
            "content_html": "<p>PHP’de kullanıcı oturumlarını yönetmek için birtakım fonksiyon kullanılır. İnternet sitesini ziyaret eden her bir kullanıcı için, sunucu üzerinde bir dosya oluşturulur ve kullanıcı oturumuna ait veriler bu dosya içerisine kaydedilir. Sunucu üzerinde bulunan session dosyası ile ziyaretçinin eşleştirilmesi için ise, istemci üzerinde bir cookie oluşturulur. Tüm bu işlemler için PHP session fonksiyonları ve başlatılmış oturumlar için kullanılan $_SESSION dizisi ile kabaca oturum yönetimi yapılabilir.</p><p>PHP’de bir oturum başlatmak için en yalın haliyle aşağıdaki gibi bir kod çalıştırılabilir.</p><figure class=\"highlight\"><pre><code class=\"language-php\" data-lang=\"php\"><span class=\"cp\">&lt;?php</span><span class=\"nb\">session_start</span><span class=\"p\">();</span><span class=\"nv\">$username</span> <span class=\"o\">=</span> <span class=\"s2\">\"Test\"</span><span class=\"p\">;</span><span class=\"nv\">$_SESSION</span><span class=\"p\">[</span><span class=\"s2\">\"username\"</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nv\">$username</span><span class=\"p\">;</span><span class=\"cp\">?&gt;</span></code></pre></figure><p>Buradaki session_start() fonksiyonuyla yeni bir oturum başlatılır. Oturum başlatıldıktan sonra, oturum verilerinin tutulacağı $_SESSION dizisine, username isimli değişkendeki veri atanır.</p><figure class=\"highlight\"><pre><code class=\"language-php\" data-lang=\"php\"><span class=\"cp\">&lt;?php</span><span class=\"nb\">session_start</span><span class=\"p\">();</span><span class=\"k\">echo</span> <span class=\"s2\">\"Kullanıcı Adı:\"</span><span class=\"mf\">.</span><span class=\"nv\">$_SESSION</span><span class=\"p\">[</span><span class=\"s2\">\"username\"</span><span class=\"p\">];</span><span class=\"cp\">?&gt;</span></code></pre></figure><p>Burada ise session_start() ile oturum başlatılarak daha önce $_SESSION[‘username’] değişkenine atanan veri ekrana yazdırılır.</p><p>Herhangi bir zaman, oturum sonlandırılmak ve session verileri silinmek istenirse session_destroy() fonksiyonu çalıştırılır.</p>",
            "url": "https://hakan.io/php-session-kullanimi/",
            
            
            
            "tags": ["php","session","php session kullanımı","php oturum yönetimi"],
            
            "date_published": "2011-12-28T04:12:01+02:00",
            "date_modified": "2011-12-28T04:12:01+02:00",
            
                "author": "Hakan"
            
        },
    
        {
            "id": "https://hakan.io/ubuntu-11-10-ubuntu-classic-kullanmak/",
            "title": "Ubuntu 11.10 - Ubuntu Classic Kullanmak",
            "summary": null,
            "content_text": "Ubuntu 11.10 dağıtımı ile birlikte gelen unity klasik Gnome Ubuntu kullanıcılarını çileden çıkarmaya devam ediyor. Klasik Gnome görünümü için Ubuntu 11.04 Natty’de Login kısmında Ubuntu Classic seçilerek sorun çözülüyordu ancak Ubuntu 11.10’da bu durum ortadan kalkmış durumda. Ancak bunu kısmen çözmek mümkün.Bunun için ubuntu-shell ve ubuntu-session-fallback paketlerinin kurulması gerek. Bunun için;apt-get install ubuntu-shellapt-get install ubuntu-session-fallbackile paketleri kuruyoruz ve ardından tekrar login oluyoruz. Login olurken sağdaki seçenekler ikonu vasıtasıyla Ubuntu Classic seçiyoruz. Bu kısmen sorunu çözüyor. Ancak benim gibi root olarak sisteminizi kullanıyorsanız sorun yaşayabilirsiniz. Root olarak login olmak isterseniz Ubuntu Classic kullanamıyorsunuz ancak normal kullanıcı rollerinde bir problem yok.Şahsen tekrardan Ubuntu 11.04’e ya da Xubuntu’ya geçmeyi düşünüyorum.",
            "content_html": "<p>Ubuntu 11.10 dağıtımı ile birlikte gelen unity klasik Gnome Ubuntu kullanıcılarını çileden çıkarmaya devam ediyor. Klasik Gnome görünümü için Ubuntu 11.04 Natty’de Login kısmında Ubuntu Classic seçilerek sorun çözülüyordu ancak Ubuntu 11.10’da bu durum ortadan kalkmış durumda. Ancak bunu kısmen çözmek mümkün.</p><p>Bunun için ubuntu-shell ve ubuntu-session-fallback paketlerinin kurulması gerek. Bunun için;</p><figure class=\"highlight\"><pre><code class=\"language-bash\" data-lang=\"bash\">apt-get <span class=\"nb\">install </span>ubuntu-shellapt-get <span class=\"nb\">install </span>ubuntu-session-fallback</code></pre></figure><p>ile paketleri kuruyoruz ve ardından tekrar login oluyoruz. Login olurken sağdaki seçenekler ikonu vasıtasıyla Ubuntu Classic seçiyoruz. Bu kısmen sorunu çözüyor. Ancak benim gibi root olarak sisteminizi kullanıyorsanız sorun yaşayabilirsiniz. Root olarak login olmak isterseniz Ubuntu Classic kullanamıyorsunuz ancak normal kullanıcı rollerinde bir problem yok.</p><p>Şahsen tekrardan Ubuntu 11.04’e ya da Xubuntu’ya geçmeyi düşünüyorum.</p>",
            "url": "https://hakan.io/ubuntu-11-10-ubuntu-classic-kullanmak/",
            
            
            
            "tags": ["linux","ubuntu","ubuntu-classic"],
            
            "date_published": "2011-12-25T23:44:53+02:00",
            "date_modified": "2011-12-25T23:44:53+02:00",
            
                "author": "Hakan"
            
        },
    
        {
            "id": "https://hakan.io/php-ereg_replace-kullanimi/",
            "title": "PHP ereg_replace Fonksiyonu",
            "summary": null,
            "content_text": "Bazen PHP’de bir takım manipülasyonlar yapmanız gerekebilir. Bu anlarda kendi fonksiyonlarımız iş gördüğü gibi PHP fonksiyonları da imdadınıza koşuyor.Şimdi bu fonksiyonlardan sadece birisi olan ereg_replace fonksiyonu hakkında biraz bilgi verelim. ereg_replace fonksiyonu stringler üzerinde manipülasyon yapmanıza olanak sağlıyor. Örneğin;“Bugün hava çok sisli” cümlesindeki sisli kelimesini yağmurlu ile değiştirmek için;&lt;?php$cumle=\"Bugün hava çok sisli\";$cumle=ereg_replace(\"sisli\",\"yağmurlu\",$cumle);?&gt;gibi bir yöntem izlememiz gerekiyor.ereg_replace fonksiyonunun en basit haliyle kullanımı bu şekilde. İlerleyen safhalarda düzenli ifadelerle kullanılması ile birlikte, iş yükünü çok hafifleteceğini hatırlatayım.Zamanın ötesinden not: PHP7 ile birlikte ereg_replace fonksiyonu tarihe karıştı.",
            "content_html": "<p>Bazen PHP’de bir takım manipülasyonlar yapmanız gerekebilir. Bu anlarda kendi fonksiyonlarımız iş gördüğü gibi PHP fonksiyonları da imdadınıza koşuyor.</p><p>Şimdi bu fonksiyonlardan sadece birisi olan ereg_replace fonksiyonu hakkında biraz bilgi verelim. ereg_replace fonksiyonu stringler üzerinde manipülasyon yapmanıza olanak sağlıyor. Örneğin;</p><p>“Bugün hava çok sisli” cümlesindeki sisli kelimesini yağmurlu ile değiştirmek için;</p><figure class=\"highlight\"><pre><code class=\"language-php\" data-lang=\"php\"><span class=\"cp\">&lt;?php</span><span class=\"nv\">$cumle</span><span class=\"o\">=</span><span class=\"s2\">\"Bugün hava çok sisli\"</span><span class=\"p\">;</span><span class=\"nv\">$cumle</span><span class=\"o\">=</span><span class=\"nb\">ereg_replace</span><span class=\"p\">(</span><span class=\"s2\">\"sisli\"</span><span class=\"p\">,</span><span class=\"s2\">\"yağmurlu\"</span><span class=\"p\">,</span><span class=\"nv\">$cumle</span><span class=\"p\">);</span><span class=\"cp\">?&gt;</span></code></pre></figure><p>gibi bir yöntem izlememiz gerekiyor.</p><p>ereg_replace fonksiyonunun en basit haliyle kullanımı bu şekilde. İlerleyen safhalarda düzenli ifadelerle kullanılması ile birlikte, iş yükünü çok hafifleteceğini hatırlatayım.</p><p>Zamanın ötesinden not: PHP7 ile birlikte ereg_replace fonksiyonu tarihe karıştı.</p>",
            "url": "https://hakan.io/php-ereg_replace-kullanimi/",
            
            
            
            "tags": ["ereg_replace","ereg_replace fonksiyonu kullanımı","php ereg_replace fonksiyonu"],
            
            "date_published": "2011-12-23T12:33:55+02:00",
            "date_modified": "2011-12-23T12:33:55+02:00",
            
                "author": "Hakan"
            
        },
    
        {
            "id": "https://hakan.io/hello-world/",
            "title": "Hello World!",
            "summary": null,
            "content_text": "“Erica Albright is a bitch” diye başlayan bir blog yazmak isterdim ama ne Erica diye bir kız arkadaşım var ne de şu anda kadınları çiftlik hayvanları ile karşılaştırma fikrine sahibim.The Social Network (2010)Bu ilk yazım, Dennis Ritchie’nin “The C Programming Language” de tanımladığı ilk C programı için kullandığı tabir olan;#include &lt;stdio.h&gt; int main() {printf(\"hello world!\");}tanımlamasından doğan “Hello World” akımına kapılan her “coder(!)” gibi ben de böyle bir başlıkla başladım. Hadi bakalım bloglayalım!",
            "content_html": "<p>“Erica Albright is a bitch” diye başlayan bir blog yazmak isterdim ama ne Erica diye bir kız arkadaşım var ne de şu anda kadınları çiftlik hayvanları ile karşılaştırma fikrine sahibim.</p><p><img src=\"/assets/images/post/the-social-network-zuckonit.png\" alt=\"The Social Network Zuckonit\" title=\"The Social Network Zuckonit\" /><em>The Social Network (2010)</em></p><p>Bu ilk yazım, Dennis Ritchie’nin “The C Programming Language” de tanımladığı ilk C programı için kullandığı tabir olan;</p><figure class=\"highlight\"><pre><code class=\"language-c\" data-lang=\"c\"><span class=\"cp\">#include &lt;stdio.h&gt; </span><span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span> <span class=\"p\">{</span><span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"hello world!\"</span><span class=\"p\">);</span><span class=\"p\">}</span></code></pre></figure><p>tanımlamasından doğan “Hello World” akımına kapılan her “coder(!)” gibi ben de böyle bir başlıkla başladım. Hadi bakalım bloglayalım!</p>",
            "url": "https://hakan.io/hello-world/",
            
            
            
            
            
            "date_published": "2011-12-21T01:21:13+02:00",
            "date_modified": "2011-12-21T01:21:13+02:00",
            
                "author": "Hakan"
            
        }
    
    ]
}